<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>简历</title>
      <link href="/2025/09/14/jian-li/"/>
      <url>/2025/09/14/jian-li/</url>
      
        <content type="html"><![CDATA[<p><img src="/../images/cmfhnpx6e04a2svi2pvvr05gn.webp" alt="cmfhnpx6e04a2svi2pvvr05gn"></p>]]></content>
      
      
      <categories>
          
          <category> 简历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg处理音视频</title>
      <link href="/2025/03/31/wen-jian-chu-li-xiang-mu/ffmpeg-chu-li-yin-shi-pin/"/>
      <url>/2025/03/31/wen-jian-chu-li-xiang-mu/ffmpeg-chu-li-yin-shi-pin/</url>
      
        <content type="html"><![CDATA[<h1 id="ffmpeg裁剪视频"><a href="#ffmpeg裁剪视频" class="headerlink" title="ffmpeg裁剪视频"></a>ffmpeg裁剪视频</h1><p>ffmpeg.input(input_path, **input_kwargs)：</p><p>创建一个FFmpeg输入流对象</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input_kwargs[<span class="string">'ss'</span>] = start_time</span><br><span class="line">input_kwargs[<span class="string">'to'</span>] = end_time</span><br><span class="line">input_stream = ffmpeg.<span class="built_in">input</span>(input_path, **input_kwargs)</span><br><span class="line"></span><br><span class="line">output_kwargs[<span class="string">'t'</span>] = end_time - start_time</span><br><span class="line">output_kwargs[<span class="string">'vcodec'</span>] = SUPPORTED_VIDEO_CODECS.get(video_codec, video_codec)</span><br><span class="line">output_kwargs[<span class="string">'acodec'</span>] = SUPPORTED_AUDIO_CODECS.get(audio_codec, audio_codec)</span><br><span class="line">output_kwargs[<span class="string">'format'</span>] = <span class="string">"MP3"</span></span><br><span class="line">output_stream = ffmpeg.output(input_stream, output_path, **output_kwargs)</span><br><span class="line"></span><br><span class="line">ffmpeg.run(output_stream, overwrite_output=<span class="literal">True</span>, quiet=<span class="literal">True</span>)<span class="comment"># 执行ffmpeg命令</span></span><br></pre></td></tr></tbody></table></figure><p>ss参数：</p><p>表示”seek start”，即起始时间点</p><p>告诉FFmpeg从视频的start_time时间点开始读取</p><p>to参数：</p><p>表示结束时间点</p><p>告诉FFmpeg读取到视频的end_time时间点为止</p><p>t参数：</p><p>表示流的持续时间，从流开始计时</p><p>vcodec参数：</p><p>表示视频解码器</p><p>acodec参数：<br>表示音频解码器</p><h1 id="ffmpeg提取视频内容"><a href="#ffmpeg提取视频内容" class="headerlink" title="ffmpeg提取视频内容"></a>ffmpeg提取视频内容</h1><h3 id="提取音频内容"><a href="#提取音频内容" class="headerlink" title="提取音频内容"></a>提取音频内容</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extract_audio</span>(<span class="params">input_path, output_path, audio_format, start_seconds, end_seconds, video_info</span>):</span><br><span class="line">    <span class="string">"""提取音频"""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> output_path:</span><br><span class="line">            output_path = get_default_output_path(input_path, audio_format)</span><br><span class="line">            output_path = output_path.replace(<span class="string">'_processed'</span>, <span class="string">'_audio'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ensure_directory(output_path)</span><br><span class="line">        </span><br><span class="line">        input_kwargs = {}    </span><br><span class="line">        input_kwargs[<span class="string">'ss'</span>] = start_seconds</span><br><span class="line">        input_kwargs[<span class="string">'to'</span>] = end_seconds</span><br><span class="line">        input_stream = ffmpeg.<span class="built_in">input</span>(input_path, **input_kwargs)</span><br><span class="line"></span><br><span class="line">        output_kwargs = {</span><br><span class="line">            <span class="string">'vn'</span>: <span class="literal">None</span>,</span><br><span class="line">            <span class="string">'format'</span>: audio_format</span><br><span class="line">        }</span><br><span class="line">        output_stream = create_ffmpeg_output(</span><br><span class="line">            input_stream, </span><br><span class="line">            output_path, </span><br><span class="line">            **output_kwargs</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 执行FFmpeg命令</span></span><br><span class="line">        success = execute_ffmpeg_command(output_stream, output_path)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> success:</span><br><span class="line">            logger.info(<span class="string">f"音频提取完成: <span class="subst">{output_path}</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            result = {</span><br><span class="line">                <span class="string">"success"</span>: <span class="literal">True</span>,</span><br><span class="line">                <span class="string">"data"</span>: {</span><br><span class="line">                    <span class="string">"output_path"</span>: output_path,</span><br><span class="line">                    <span class="string">"format"</span>: audio_format,</span><br><span class="line">                    <span class="string">"duration"</span>: video_info.get(<span class="string">'duration'</span>, <span class="number">0</span>) <span class="keyword">if</span> end_seconds <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="built_in">min</span>(end_seconds, video_info.get(<span class="string">'duration'</span>, <span class="number">0</span>)) - start_seconds</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            dump_json(output_path, result)</span><br><span class="line">            <span class="built_in">print</span>(json.dumps(result))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"音频提取失败"</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f"音频提取失败: <span class="subst">{<span class="built_in">str</span>(e)}</span>"</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br></pre></td></tr></tbody></table></figure><p>把output_kwargs[‘format’] = “MP3”代码中的格式改成音频格式 或 输出地址后缀为音频格式即可</p><p>部分函数是我自己封装的，但是没有上传上去，不过这些函数并不是很复杂，使用前去实现这些未实现的函数</p><h3 id="提取帧"><a href="#提取帧" class="headerlink" title="提取帧"></a>提取帧</h3><p>格式同上</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output_kwargs['r'] = min(frame_rate, video_info.get('fps', 0)) </span><br></pre></td></tr></tbody></table></figure><p>r参数：</p><p>指每秒从视频中抽取多少张照片</p><h3 id="提取字幕"><a href="#提取字幕" class="headerlink" title="提取字幕"></a>提取字幕</h3>]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python临时文件</title>
      <link href="/2025/03/26/wen-jian-chu-li-xiang-mu/python-lin-shi-wen-jian-shi-yong-fang-fa/"/>
      <url>/2025/03/26/wen-jian-chu-li-xiang-mu/python-lin-shi-wen-jian-shi-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tempfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inkscape的使用方式</title>
      <link href="/2025/03/26/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-3-26/"/>
      <url>/2025/03/26/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-3-26/</url>
      
        <content type="html"><![CDATA[<h1 id="inkscape支持的文件列表"><a href="#inkscape支持的文件列表" class="headerlink" title="inkscape支持的文件列表"></a>inkscape支持的文件列表</h1><p>矢量图支持列表，按使用频率排序：</p><ol><li><strong>SVG</strong> - 最常用网页矢量格式，支持良好，转换效果最佳</li><li><strong>PDF</strong> - 常用文档格式，包含矢量元素，转换效果好</li><li><strong>EPS</strong> - 专业印刷格式，转换效果良好</li><li><strong>AI</strong> - Adobe专业设计格式，部分支持</li><li><strong>DXF</strong> - CAD工程图格式，基本支持</li><li><strong>WMF/EMF</strong> - Windows矢量格式，支持一般</li><li><strong>SVGZ</strong> - 压缩SVG，支持良好</li><li><strong>ODG</strong> - OpenOffice绘图格式，基本支持</li><li><strong>PS</strong> - PostScript格式，支持良好</li><li><strong>XAML</strong> - 微软接口描述格式，有限支持</li><li><strong>FXG</strong> - Flash矢量格式，有限支持</li><li><strong>HPGL</strong> - 绘图仪格式，基本支持</li><li><strong>POV</strong> - 3D渲染场景格式，有限支持</li><li><strong>SIF</strong> - Synfig动画格式，有限支持</li></ol><p>非矢量格式：</p><ul><li>PNG、JPG、TIFF、WebP (栅格图像)</li><li>HTML、TEX (标记语言)</li><li>ZIP、TAR (压缩文件)</li><li>GPL (调色板文件)</li></ul><p>Inkscape主要专长于矢量图互转，栅格到矢量的转换效果有限。</p><h3 id="Inkscape-支持的文件格式"><a href="#Inkscape-支持的文件格式" class="headerlink" title="Inkscape 支持的文件格式"></a>Inkscape 支持的文件格式</h3><p><strong>可读入格式</strong>:</p><ul><li>SVG/SVGZ - 原生支持</li><li>PDF - 较好支持</li><li>EPS - 良好支持</li><li>DXF - 基本支持</li><li>AI - 部分支持</li><li>WMF/EMF - 基本支持</li><li>ODG - 基本支持</li><li>PS - 良好支持</li></ul><p><strong>可写出格式</strong>:</p><ul><li>SVG/SVGZ - 完全支持</li><li>PDF - 良好支持</li><li>EPS - 良好支持</li><li>PNG - 完全支持</li><li>JPG/JPEG - 完全支持</li><li>PS - 良好支持</li><li>DXF - 基本支持</li><li>EMF - 基本支持</li><li>WebP - 基本支持</li><li>TIFF - 基本支持</li><li>POV - 有限支持</li><li>XAML - 有限支持</li><li>FXG - 有限支持</li><li>HPGL - 有限支持</li></ul><h1 id="Inkscape文件格式转换参数指南"><a href="#Inkscape文件格式转换参数指南" class="headerlink" title="Inkscape文件格式转换参数指南"></a>Inkscape文件格式转换参数指南</h1><p>Inkscape命令行支持多种文件格式之间的转换，每种转换可以通过各种参数进行精细控制。以下是按转换类型分组的参数指南：</p><h2 id="通用导出参数（适用于大多数格式）"><a href="#通用导出参数（适用于大多数格式）" class="headerlink" title="通用导出参数（适用于大多数格式）"></a>通用导出参数（适用于大多数格式）</h2><p>这些参数几乎适用于所有类型的导出操作：</p><ul><li><code>--export-filename=FILE</code> - 指定输出文件的名称和路径</li><li><code>--export-area=x0:y0:x1:y1</code> - 指定要导出的页面区域（单位为像素）</li><li><code>--export-area-page</code> - 导出整个页面区域</li><li><code>--export-area-drawing</code> - 导出绘图的边界框区域</li><li><code>--export-id=ID</code> - 只导出指定ID的对象</li><li><code>--export-id-only</code> - 与<code>--export-id</code>一起使用，只导出该对象的边界框</li><li><code>--export-use-hints</code> - 使用存储在SVG中的导出提示（如建议的DPI值）</li><li><code>--export-background=COLOR</code> - 设置导出背景颜色（如”#ff0000”或”rgb(255,0,0)”）</li><li><code>--export-background-opacity=VALUE</code> - 设置背景透明度（0.0-1.0）</li></ul><h2 id="栅格图像导出参数（PNG、JPEG、TIFF、WebP）"><a href="#栅格图像导出参数（PNG、JPEG、TIFF、WebP）" class="headerlink" title="栅格图像导出参数（PNG、JPEG、TIFF、WebP）"></a>栅格图像导出参数（PNG、JPEG、TIFF、WebP）</h2><p>这些参数适用于导出为位图格式：</p><ul><li><code>--export-dpi=DPI</code> - 设置导出的分辨率（每英寸点数）</li><li><code>--export-width=WIDTH</code> - 设置导出图像的宽度（像素）</li><li><code>--export-height=HEIGHT</code> - 设置导出图像的高度（像素）</li><li><code>--export-margin=MARGIN</code> - 在导出对象周围添加边距（像素）</li><li><code>--export-overwrite</code> - 覆盖已存在的文件</li><li><code>--export-type=TYPE</code> - 指定图像类型（例如”png”、”jpg”等）</li></ul><h3 id="JPEG特有参数"><a href="#JPEG特有参数" class="headerlink" title="JPEG特有参数"></a>JPEG特有参数</h3><ul><li><code>--export-quality=VALUE</code> - 设置JPEG质量（0-100）</li></ul><h3 id="PNG特有参数"><a href="#PNG特有参数" class="headerlink" title="PNG特有参数"></a>PNG特有参数</h3><ul><li><code>--export-png-color-mode=COLOR_MODE</code> - 设置PNG颜色模式（”RGB”、”GRAY”或”INDEXED”）</li><li><code>--export-png-compression=LEVEL</code> - 设置PNG压缩级别（0-9）</li></ul><h2 id="矢量格式导出参数"><a href="#矢量格式导出参数" class="headerlink" title="矢量格式导出参数"></a>矢量格式导出参数</h2><h3 id="SVG导出参数"><a href="#SVG导出参数" class="headerlink" title="SVG导出参数"></a>SVG导出参数</h3><ul><li><code>--export-plain-svg</code> - 导出为标准SVG（移除Inkscape特有的标记）</li><li><code>--export-text-to-path</code> - 将文本转换为路径</li><li><code>--export-ignore-filters</code> - 忽略滤镜效果</li><li><code>--export-ps-level=LEVEL</code> - 设置PostScript级别兼容性（2或3）</li></ul><h3 id="PDF导出参数"><a href="#PDF导出参数" class="headerlink" title="PDF导出参数"></a>PDF导出参数</h3><ul><li><code>--export-pdf-version=VERSION</code> - 设置PDF版本（如”1.4”、”1.5”等）</li><li><code>--export-pdf-compresslevel=LEVEL</code> - 设置PDF压缩级别（0-9）</li><li><code>--export-latex</code> - 生成带有LaTeX支持的PDF</li><li><code>--export-embed-fonts</code> - 在PDF中嵌入字体</li><li><code>--export-text-to-path</code> - 将文本转换为路径（建议用于文本处理问题）</li><li><code>--export-ignore-filters</code> - 忽略滤镜效果</li></ul><h3 id="EPS-PS导出参数"><a href="#EPS-PS导出参数" class="headerlink" title="EPS/PS导出参数"></a>EPS/PS导出参数</h3><ul><li><code>--export-ps-level=LEVEL</code> - 设置PostScript级别兼容性（2或3）</li><li><code>--export-text-to-path</code> - 将文本转换为路径</li><li><code>--export-embed-fonts</code> - 嵌入字体</li><li><code>--export-bbox-page</code> - 使用页面尺寸作为边界框</li></ul><h3 id="DXF导出参数"><a href="#DXF导出参数" class="headerlink" title="DXF导出参数"></a>DXF导出参数</h3><ul><li><p><code>--export-dxf-polyline-mode</code> - 将所有路径导出为简单的多段线</p></li><li><p><code>--export-dxf-compatible-units</code> - 使用兼容的单位（毫米/英寸）</p></li><li><p><code>--export-dxf-force-flat</code> - 强制平面输出，移除曲线</p></li><li><p><code>--export-dxf-version=VERSION</code> - 设置DXF版本（如”R14”、”2000”等）</p></li><li><p>格式转换示例与常用方案</p><h3 id="SVG到PNG转换（网页和数字展示用）"><a href="#SVG到PNG转换（网页和数字展示用）" class="headerlink" title="SVG到PNG转换（网页和数字展示用）"></a>SVG到PNG转换（网页和数字展示用）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inkscape --export-filename=output.png --export-dpi=300 --export-background=white input.svg</span><br></pre></td></tr></tbody></table></figure><h3 id="SVG到PDF转换（印刷用）"><a href="#SVG到PDF转换（印刷用）" class="headerlink" title="SVG到PDF转换（印刷用）"></a>SVG到PDF转换（印刷用）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inkscape --export-filename=output.pdf --export-pdf-version=1.5 --export-embed-fonts --export-text-to-path input.svg</span><br></pre></td></tr></tbody></table></figure><h3 id="PDF到SVG转换（编辑用）"><a href="#PDF到SVG转换（编辑用）" class="headerlink" title="PDF到SVG转换（编辑用）"></a>PDF到SVG转换（编辑用）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inkscape --export-filename=output.svg input.pdf</span><br></pre></td></tr></tbody></table></figure><h3 id="SVG到EPS转换（专业印刷用）"><a href="#SVG到EPS转换（专业印刷用）" class="headerlink" title="SVG到EPS转换（专业印刷用）"></a>SVG到EPS转换（专业印刷用）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inkscape --export-filename=output.eps --export-ps-level=3 --export-text-to-path input.svg</span><br></pre></td></tr></tbody></table></figure><h3 id="任何格式到JPEG转换（照片式图像压缩）"><a href="#任何格式到JPEG转换（照片式图像压缩）" class="headerlink" title="任何格式到JPEG转换（照片式图像压缩）"></a>任何格式到JPEG转换（照片式图像压缩）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inkscape --export-filename=output.jpg --export-quality=90 --export-background=white --export-dpi=300 input.svg</span><br></pre></td></tr></tbody></table></figure><h3 id="DXF转SVG（CAD文件导入编辑）"><a href="#DXF转SVG（CAD文件导入编辑）" class="headerlink" title="DXF转SVG（CAD文件导入编辑）"></a>DXF转SVG（CAD文件导入编辑）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inkscape --export-filename=output.svg input.dxf</span><br></pre></td></tr></tbody></table></figure><h2 id="批量转换不同文件类型的示例脚本"><a href="#批量转换不同文件类型的示例脚本" class="headerlink" title="批量转换不同文件类型的示例脚本"></a>批量转换不同文件类型的示例脚本</h2><p>下面是一个示例脚本，展示如何批量处理不同类型的文件转换：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># SVG到PNG批量转换（网页用）</span><br><span class="line">for file in *.svg; do</span><br><span class="line">  inkscape --export-filename="${file%.svg}.png" --export-dpi=96 --export-background-opacity=0 "$file"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># SVG到PDF批量转换（印刷用）</span><br><span class="line">for file in *.svg; do</span><br><span class="line">  inkscape --export-filename="${file%.svg}.pdf" --export-pdf-version=1.5 --export-embed-fonts "$file"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># PDF到SVG批量转换</span><br><span class="line">for file in *.pdf; do</span><br><span class="line">  inkscape --export-filename="${file%.pdf}.svg" --export-plain-svg "$file"</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="Inkscape命令行的使用方法"><a href="#Inkscape命令行的使用方法" class="headerlink" title="Inkscape命令行的使用方法"></a>Inkscape命令行的使用方法</h1><p>Inkscape不仅提供图形界面，还有强大的命令行功能，允许您在不打开界面的情况下处理SVG文件。以下是Inkscape常用的命令行指令：</p><h2 id="基本命令行语法"><a href="#基本命令行语法" class="headerlink" title="基本命令行语法"></a>基本命令行语法</h2><p>Inkscape的命令行基本语法是：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inkscape [选项] [文件名...]</span><br></pre></td></tr></tbody></table></figure><h2 id="导出和转换指令"><a href="#导出和转换指令" class="headerlink" title="导出和转换指令"></a>导出和转换指令</h2><p>Inkscape最常用的命令行功能是将SVG文件导出为其他格式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 将SVG导出为PNG</span><br><span class="line">inkscape --export-filename=输出文件.png 输入文件.svg</span><br><span class="line"></span><br><span class="line"># 指定导出PNG的分辨率（DPI）</span><br><span class="line">inkscape --export-dpi=300 --export-filename=输出文件.png 输入文件.svg</span><br><span class="line"></span><br><span class="line"># 导出为PDF</span><br><span class="line">inkscape --export-filename=输出文件.pdf 输入文件.svg</span><br><span class="line"></span><br><span class="line"># 导出为EPS</span><br><span class="line">inkscape --export-filename=输出文件.eps 输入文件.svg</span><br><span class="line"></span><br><span class="line"># 导出为Plain SVG（移除Inkscape特定标记）</span><br><span class="line">inkscape --export-plain-svg --export-filename=输出文件.svg 输入文件.svg</span><br></pre></td></tr></tbody></table></figure><h2 id="裁剪和区域处理"><a href="#裁剪和区域处理" class="headerlink" title="裁剪和区域处理"></a>裁剪和区域处理</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bashCopy# 导出特定页面区域（x,y,宽,高，单位为像素）</span><br><span class="line">inkscape --export-area=100:100:300:300 --export-filename=裁剪图片.png 输入文件.svg</span><br><span class="line"></span><br><span class="line"># 导出绘图区域</span><br><span class="line">inkscape --export-area-page --export-filename=页面区域.png 输入文件.svg</span><br><span class="line"></span><br><span class="line"># 导出图形绘制边界</span><br><span class="line">inkscape --export-area-drawing --export-filename=图形边界.png 输入文件.svg</span><br></pre></td></tr></tbody></table></figure><h2 id="选择和操作对象"><a href="#选择和操作对象" class="headerlink" title="选择和操作对象"></a>选择和操作对象</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bashCopy# 选择特定ID的对象并导出</span><br><span class="line">inkscape --export-id=对象ID --export-filename=对象.png 输入文件.svg</span><br><span class="line"></span><br><span class="line"># 导出对象并添加边距（以像素为单位）</span><br><span class="line">inkscape --export-id=对象ID --export-id-only --export-margin=10 --export-filename=对象带边距.png 输入文件.svg</span><br></pre></td></tr></tbody></table></figure><h2 id="批处理多个文件"><a href="#批处理多个文件" class="headerlink" title="批处理多个文件"></a>批处理多个文件</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bashCopy# 使用循环批处理多个SVG文件</span><br><span class="line">for file in *.svg; do</span><br><span class="line">    inkscape --export-filename="${file%.svg}.png" "$file"</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure><h2 id="查询和打印信息"><a href="#查询和打印信息" class="headerlink" title="查询和打印信息"></a>查询和打印信息</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bashCopy# 列出文档中所有对象的ID</span><br><span class="line">inkscape --query-all 输入文件.svg</span><br><span class="line"></span><br><span class="line"># 获取特定对象的信息</span><br><span class="line">inkscape --query-id=对象ID 输入文件.svg</span><br></pre></td></tr></tbody></table></figure><h2 id="执行动作和修改"><a href="#执行动作和修改" class="headerlink" title="执行动作和修改"></a>执行动作和修改</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bashCopy# 应用滤镜效果</span><br><span class="line">inkscape --actions="select-all;filter:blur;" --export-filename=模糊效果.svg 输入文件.svg</span><br><span class="line"></span><br><span class="line"># 执行多个操作（0.92版本后支持）</span><br><span class="line">inkscape --actions="select-all;object-to-path;export-filename:路径版本.svg;export-do" 输入文件.svg</span><br></pre></td></tr></tbody></table></figure><h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bashCopy# 显示完整的命令行帮助</span><br><span class="line">inkscape --help</span><br><span class="line"></span><br><span class="line"># 显示版本信息</span><br><span class="line">inkscape --version</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是，Inkscape的命令行参数在不同版本之间有所变化。在Inkscape 1.0以前，许多选项使用单破折号和不同的参数名（如<code>--export-png</code>而不是<code>--export-filename</code>）。如果您使用的是较旧版本的Inkscape，可能需要调整这些命令。</p>]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> inkscape </tag>
            
            <tag> 矢量图像的相互转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在windows上安装inkscape</title>
      <link href="/2025/03/26/wen-jian-chu-li-xiang-mu/zai-windows-shang-an-zhuang-inkscape/"/>
      <url>/2025/03/26/wen-jian-chu-li-xiang-mu/zai-windows-shang-an-zhuang-inkscape/</url>
      
        <content type="html"><![CDATA[<p>Inkscape是一个开源的矢量图形编辑器，它提供了命令行接口，可以通过命令行来执行各种操作，例如将SVG文件转换为其他格式，执行批量操作等。</p><p>以下是在Windows上安装Inkscape并在命令行中执行一些常见操作的一般步骤：</p><ol><li><p><strong>安装Inkscape</strong>：</p><ul><li>下载Inkscape的Windows安装程序（.exe文件）从官方网站：<a href="https://inkscape.org/">https://inkscape.org/</a></li><li>执行安装程序，按照安装向导的步骤安装Inkscape。</li></ul><p>2.<strong>添加Inkscape到系统路径</strong>（可选）：</p></li></ol><p>若要能够在命令行中直接访问Inkscape，请将Inkscape的安装路径添加到系统的环境变量中。这将允许在命令行中使用<code>inkscape</code>命令。</p><p>   <strong>3.在命令行中使用Inkscape</strong>：**</p><ul><li>打开命令行窗口（例如，使用Windows的cmd或PowerShell）。</li><li>若要使用Inkscape进行转换操作，可以使用以下命令的一种：</li></ul><figure class="highlight verilog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inkscape --<span class="keyword">export</span>-filename=<span class="keyword">output</span><span class="variable">.png</span> <span class="keyword">input</span><span class="variable">.svg</span></span><br></pre></td></tr></tbody></table></figure><ul><li>上述命令将将<code>input.svg</code>文件转换为<code>output.png</code>文件。可以根据需要更改输入和输出文件的名称和格式。</li></ul><p>补充，，，，，，如何用python调用inkscape</p><p>通过python中的标准库subprocess模块</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_svg_to_pdf</span>(<span class="params">input_file, output_file</span>):</span><br><span class="line">    subprocess.run([<span class="string">'inkscape'</span>, input_file, <span class="string">'--export-filename'</span>, output_file])</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">convert_svg_to_pdf(<span class="string">'input.svg'</span>, <span class="string">'output.pdf'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置更多参数</span></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_with_options</span>(<span class="params">input_file, output_file, dpi=<span class="number">300</span>, area=<span class="string">'page'</span></span>):</span><br><span class="line">    cmd = [</span><br><span class="line">        <span class="string">'inkscape'</span>,</span><br><span class="line">        input_file,</span><br><span class="line">        <span class="string">'--export-filename'</span>, output_file,</span><br><span class="line">        <span class="string">f'--export-dpi=<span class="subst">{dpi}</span>'</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">if</span> area == <span class="string">'page'</span>:</span><br><span class="line">        cmd.append(<span class="string">'--export-area-page'</span>)</span><br><span class="line">    subprocess.run(cmd)</span><br></pre></td></tr></tbody></table></figure><p><code>subprocess</code>模块是Python标准库的一部分，用于生成新进程、连接它们的输入/输出/错误管道，以及获取返回码。在前面的例子中，它用于:</p><ol><li>启动外部程序(Inkscape)作为子进程</li><li>传递命令行参数给Inkscape</li><li>等待Inkscape完成执行</li><li>获取执行结果(成功/失败)</li></ol><p><code>subprocess.run()</code>是一个高级函数，它会阻塞当前Python程序直到子进程完成执行。您可以通过它调用任何命令行程序，如Inkscape、ImageMagick或其他转换工具。</p>]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> inkscape </tag>
            
            <tag> subprocess </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7的yum镜像源</title>
      <link href="/2025/03/24/centos7-de-yum-jing-xiang-yuan/"/>
      <url>/2025/03/24/centos7-de-yum-jing-xiang-yuan/</url>
      
        <content type="html"><![CDATA[<p>已经到达生命周期终结的CentOS 7，可以使用vault镜像：</p><p>（记得备份）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sudo cat &gt; /etc/yum.repos.d/CentOS-Base.repo &lt;&lt; EOF</span><br><span class="line">[base]</span><br><span class="line">name=CentOS-7 - Base</span><br><span class="line">baseurl=https://vault.centos.org/7.9.2009/os/\$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-7 - Updates</span><br><span class="line">baseurl=https://vault.centos.org/7.9.2009/updates/\$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-7 - Extras</span><br><span class="line">baseurl=https://vault.centos.org/7.9.2009/extras/\$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line">enabled=1</span><br><span class="line">EOF</span><br></pre></td></tr></tbody></table></figure><p>.清除并重建缓存</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum clean all</span><br><span class="line">sudo yum makecache</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> CentOS7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vault镜像源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PILLOW使用方法文档</title>
      <link href="/2025/03/23/wen-jian-chu-li-xiang-mu/pillow-de-shi-yong-fang-fa/"/>
      <url>/2025/03/23/wen-jian-chu-li-xiang-mu/pillow-de-shi-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="PILLOW支持的文件类型"><a href="#PILLOW支持的文件类型" class="headerlink" title="PILLOW支持的文件类型"></a>PILLOW支持的文件类型</h1><p>pillow是一种功能强大的处理格栅图的库，其主要支持的格式有下面这几种</p><h2 id="同时支持读取和写入的格式"><a href="#同时支持读取和写入的格式" class="headerlink" title="同时支持读取和写入的格式"></a>同时支持读取和写入的格式</h2><ol><li><p>BMP</p><p> - Windows位图</p><ul><li>特点：无压缩或RLE压缩，文件较大但无损</li><li>扩展名：.bmp, .dib</li></ul></li><li><p>GIF</p><p> - 图形交换格式</p><ul><li>特点：最多256色，支持透明和动画</li><li>扩展名：.gif</li></ul></li><li><p>JPEG/JPG</p><p> - 联合图像专家组格式</p><ul><li>特点：有损压缩，适合照片</li><li>扩展名：.jpg, .jpeg, .jpe</li></ul></li><li><p>PNG</p><p> - 便携式网络图形</p><ul><li>特点：无损压缩，支持透明度</li><li>扩展名：.png</li></ul></li><li><p>PPM/PGM/PBM</p><p> - 便携式像素/灰度/位图</p><ul><li>特点：简单格式，分别用于彩色/灰度/二值图像</li><li>扩展名：.ppm, .pgm, .pbm</li></ul></li><li><p>TIFF/TIF</p><p> - 标签图像文件格式</p><ul><li>特点：灵活，支持多页和多种压缩算法</li><li>扩展名：.tiff, .tif</li></ul></li><li><p>WebP</p><p> - Google网络图片格式</p><ul><li>特点：同时支持有损和无损压缩，文件小</li><li>扩展名：.webp</li></ul></li><li><p>ICO</p><p> - Windows图标</p><ul><li>特点：包含多个尺寸的图像</li><li>扩展名：.ico</li></ul></li><li><p>PCX</p><p> - PC画笔格式</p><ul><li>特点：早期PC绘图软件格式</li><li>扩展名：.pcx</li></ul></li><li><p>TGA</p><p> - Truevision图形适配器格式</p><ul><li>特点：支持透明度和32位色深</li><li>扩展名：.tga</li></ul></li></ol><h2 id="主要支持读取但写入功能有限的格式"><a href="#主要支持读取但写入功能有限的格式" class="headerlink" title="主要支持读取但写入功能有限的格式"></a>主要支持读取但写入功能有限的格式</h2><ol><li><p>EPS</p><p> - Encapsulated PostScript</p><ul><li>特点：通常只支持栅格化预览的读取</li><li>扩展名：.eps</li></ul></li><li><p>ICNS</p><p> - Apple图标</p><ul><li>特点：苹果系统的图标格式</li><li>扩展名：.icns</li></ul></li><li><p>IM</p><p> - IFUNC图像内存格式</p><ul><li>特点：用于图像处理</li><li>扩展名：.im</li></ul></li><li><p>MSP</p><p> - Windows画图格式</p><ul><li>特点：旧版Windows绘图程序格式</li><li>扩展名：.msp</li></ul></li><li><p>DCX</p><p> - PCX文件的多页版本</p><ul><li>特点：包含多个PCX图像</li><li>扩展名：.dcx</li></ul></li></ol><h2 id="主要支持写入但读取功能有限的格式"><a href="#主要支持写入但读取功能有限的格式" class="headerlink" title="主要支持写入但读取功能有限的格式"></a>主要支持写入但读取功能有限的格式</h2><ol><li><p>PDF</p><p> - 便携式文档格式</p><ul><li>特点：需要额外依赖(reportlab)才能写入</li><li>扩展名：.pdf</li></ul></li><li><p>PS</p><p> - PostScript</p><ul><li>特点：用于打印的页面描述语言</li><li>扩展名：.ps</li></ul></li><li><p>EPS</p><p> (写入) - 需要额外配置</p><ul><li>特点：矢量图形格式，写入功能有限</li><li>扩展名：.eps</li></ul></li></ol><h2 id="Pillow无法支持的常见格式"><a href="#Pillow无法支持的常见格式" class="headerlink" title="Pillow无法支持的常见格式"></a>Pillow无法支持的常见格式</h2><ol><li><p>SVG</p><p> - 可缩放矢量图形</p><ul><li>原因：Pillow主要处理光栅图像，不支持矢量格式</li><li>替代方案：svglib, cairosvg, drawSvg</li></ul></li><li><p>PSD</p><p> - Photoshop文档</p><ul><li>原因：只有有限的读取支持，不支持写入</li><li>替代方案：psd_tools库</li></ul></li><li><p>HEIF/HEIC</p><p> - 高效图像文件格式</p><ul><li>原因：需要外部依赖</li><li>替代方案：pillow-heif扩展</li></ul></li></ol><p>Pillow是Python中最流行的图像处理库之一。它是PIL (Python Imaging Library) 的一个分支和继承者，因为原始的PIL项目已经不再活跃更新。Pillow提供了丰富的图像处理功能，包括但不限于：</p><ol><li>图像格式转换 - 支持多种格式之间的转换，如JPEG、PNG、BMP、TIFF、GIF等</li><li>图像调整和变换 - 缩放、旋转、裁剪、翻转等操作</li><li>图像增强和滤镜 - 亮度、对比度调整，锐化，模糊等</li><li>绘图功能 - 在图像上绘制文字、线条、矩形等图形元素</li><li>图像分析 - 颜色直方图、通道分离等</li></ol><p>Pillow在数据科学、web开发、自动化处理和图像分析等领域广泛应用。它的API设计简单直观，使得即使是编程初学者也能相对容易地进行图像处理。</p><p>需要注意的是，虽然Pillow功能强大，但它主要处理的是像素级的栅格图像，对于矢量图形（如SVG）的支持有限。</p><h2 id="市面上常见的矢量图形格式包括："><a href="#市面上常见的矢量图形格式包括：" class="headerlink" title="市面上常见的矢量图形格式包括："></a>市面上常见的矢量图形格式包括：</h2><ol><li><strong>SVG (Scalable Vector Graphics)</strong> - 基于XML的开放标准格式，被广泛支持于web环境，是最常用的矢量格式之一</li><li><strong>AI (Adobe Illustrator)</strong> - Adobe Illustrator的原生文件格式，在设计和印刷行业广泛使用</li><li><strong>EPS (Encapsulated PostScript)</strong> - 一种较老但仍然流行的格式，特别是在印刷领域</li><li><strong>PDF (Portable Document Format)</strong> - 虽然主要用于文档，但PDF也可以包含高质量的矢量图形</li><li><strong>CDR (CorelDRAW)</strong> - CorelDRAW的原生文件格式，在某些设计领域很受欢迎</li><li><strong>DXF/DWG</strong> - 主要用于CAD（计算机辅助设计）领域的矢量格式</li><li><strong>EMF/WMF (Enhanced/Windows Metafile)</strong> - 微软Windows系统中使用的矢量格式</li><li><strong>AFDESIGN</strong> - Affinity Designer的原生文件格式，是Illustrator的替代品</li><li><strong>SKETCH</strong> - Sketch软件使用的格式，在UI/UX设计中很流行</li><li><strong>XD</strong> - Adobe XD设计工具的文件格式</li></ol><p>这些矢量格式的主要优势在于它们可以无损放大缩小，文件大小通常较小（对于简单图形），并且可以轻松编辑各个元素的属性。不同的格式适用于不同的应用场景和软件生态系统。</p><h1 id="PILLOW压缩常见位图的方法"><a href="#PILLOW压缩常见位图的方法" class="headerlink" title="PILLOW压缩常见位图的方法"></a>PILLOW压缩常见位图的方法</h1><h2 id="压缩JPE-JPEG图像"><a href="#压缩JPE-JPEG图像" class="headerlink" title="压缩JPE/JPEG图像"></a>压缩JPE/JPEG图像</h2><p>在 Python 的 Pillow 库中，使用 Image.save() 方法保存 JPEG 图像时，有几个重要参数可以控制压缩质量和特性：</p><ol><li><p><code>quality</code>：最重要的参数，取值范围从 1（最差质量，最小文件）到 95（最佳质量，最大文件）。默认值是 75。</p></li><li><p><code>optimize</code>：布尔参数（True/False），决定是否对图像进行额外优化以减小文件大小。默认为 False。</p></li><li><p><code>progressive</code>：设置为 True 时，创建渐进式 JPEG 文件，可在浏览器中逐步加载。默认为 False。</p></li><li><p><code>dpi</code>：设置保存图像的 DPI（每英寸点数），格式为元组 (x_dpi, y_dpi)。</p></li><li><p><code>icc_profile</code>：允许在 JPEG 文件中嵌入 ICC 颜色配置文件。</p></li><li><p><code>exif</code>：启用在保存的图像中包含 EXIF 元数据。</p></li><li><pre><code>subsampling<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   ：控制色度子采样。选项包括：</span><br><span class="line"></span><br><span class="line">   - '4:4:4'：无子采样（最高质量）</span><br><span class="line">   - '4:2:2'：水平子采样</span><br><span class="line">   - '4:2:0'：水平和垂直子采样（默认值）</span><br><span class="line">   - '4:1:1'：高水平子采样</span><br><span class="line"></span><br><span class="line">8. `qtables`：适用于高级用户，允许指定自定义量化表。</span><br><span class="line"></span><br><span class="line">下面是使用这些参数的示例代码：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line"># 打开图像</span><br><span class="line">img = Image.open('input.jpg')</span><br><span class="line"></span><br><span class="line"># 使用各种 JPEG 压缩参数保存</span><br><span class="line">img.save('output.jpg', </span><br><span class="line">         format='JPEG', </span><br><span class="line">         quality=85,  # 更高质量</span><br><span class="line">         optimize=True,  # 启用优化</span><br><span class="line">         progressive=True,  # 创建渐进式 JPEG</span><br><span class="line">         subsampling='4:4:4')  # 无色度子采样，最高质量</span><br></pre></td></tr></tbody></table></figure></code></pre></li></ol><h2 id="压缩PNG图像"><a href="#压缩PNG图像" class="headerlink" title="压缩PNG图像"></a>压缩PNG图像</h2><p><code>optimize</code> - 这是一个布尔参数，用于确定是否对PNG文件进行大小优化。当设置为<code>True</code>时，PILLOW会尝试不同的过滤方法来减少文件大小。</p><p><code>compress_level</code> - 这是一个从0到9的整数，用于控制压缩级别。数值越高，生成的文件越小，但处理时间越长。默认值通常为6。</p><p><code>bits</code> - 控制图像的位深度（标准图像通常为8位，但可以是1、2、4、8或16，取决于图像类型）。</p><p><code>quantize</code> - 这是一个用于色彩量化的选项，可减少图像中使用的颜色数量。</p><p><code>dither</code> - 与量化一起使用，用于控制在减少调色板时颜色的分布方式。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个图像</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">"input.png"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1：基本保存，使用默认参数</span></span><br><span class="line">img.save(<span class="string">"output_default.png"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：使用optimize参数优化文件大小</span></span><br><span class="line">img.save(<span class="string">"output_optimized.png"</span>, optimize=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3：设置压缩级别</span></span><br><span class="line"><span class="comment"># compress_level的范围是0-9，0表示不压缩，9表示最大压缩</span></span><br><span class="line">img.save(<span class="string">"output_compressed.png"</span>, compress_level=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例4：同时使用optimize和compress_level</span></span><br><span class="line">img.save(<span class="string">"output_opt_comp.png"</span>, optimize=<span class="literal">True</span>, compress_level=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例5：在转换为PNG之前进行色彩量化</span></span><br><span class="line"><span class="comment"># 将图像转换为使用256种颜色的模式</span></span><br><span class="line">img_quantized = img.quantize(colors=<span class="number">256</span>)</span><br><span class="line">img_quantized.save(<span class="string">"output_quantized.png"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例6：色彩量化时使用抖动</span></span><br><span class="line">img_dithered = img.quantize(colors=<span class="number">256</span>, dither=Image.FLOYDSTEINBERG)</span><br><span class="line">img_dithered.save(<span class="string">"output_dithered.png"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例7：减少位深度（对于某些类型的图像）</span></span><br><span class="line"><span class="comment"># 转换为1位深度（黑白图像）</span></span><br><span class="line"><span class="keyword">if</span> img.mode != <span class="string">"1"</span>:</span><br><span class="line">    img_1bit = img.convert(<span class="string">"1"</span>)</span><br><span class="line">    img_1bit.save(<span class="string">"output_1bit.png"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例8：组合多种参数进行高度优化</span></span><br><span class="line">img.save(<span class="string">"output_highly_optimized.png"</span>, </span><br><span class="line">         optimize=<span class="literal">True</span>,</span><br><span class="line">         compress_level=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例9：保存为调色板模式（适合图标、图表等简单图像）</span></span><br><span class="line"><span class="keyword">if</span> img.mode != <span class="string">"P"</span>:</span><br><span class="line">    img_palette = img.convert(<span class="string">"P"</span>, palette=Image.ADAPTIVE, colors=<span class="number">256</span>)</span><br><span class="line">    img_palette.save(<span class="string">"output_palette.png"</span>, optimize=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure><p>这些示例展示了如何使用不同的参数来控制PNG图像的压缩和优化。</p><p>几点重要说明：</p><ol><li><code>optimize=True</code> 通常是减小文件大小的最简单方法，PILLOW会自动尝试找到最佳的过滤方法。</li><li><code>compress_level</code> 值越高，压缩率越高，但处理时间也越长。值为9时提供最大压缩，但可能会显著增加保存时间。</li><li>色彩量化（减少颜色数量）可以大大减小文件大小，特别是对于颜色丰富的图像。</li><li>抖动（dither）可以在减少颜色数量时保持视觉质量，尤其是在渐变区域。</li><li>对于简单的图形、图标或文本图像，减少位深度（如转换为1位或8位）可以显著减小文件大小。</li></ol><h2 id="压缩Webp图像"><a href="#压缩Webp图像" class="headerlink" title="压缩Webp图像"></a>压缩Webp图像</h2><p>WebP的优势在于它灵活性强，你可以根据需要选择无损模式（类似PNG但文件更小）或有损模式（类似JPEG但文件更小且支持透明度）。这种灵活性使它成为网页图像的理想选择，可以兼顾质量和加载速度。</p><h3 id="WebP压缩的主要参数"><a href="#WebP压缩的主要参数" class="headerlink" title="WebP压缩的主要参数"></a>WebP压缩的主要参数</h3><ol><li><p><strong>quality</strong> - 有损压缩的质量，范围0-100。类似于JPEG的质量设置。</p></li><li><p><strong>lossless</strong> - 布尔值，设为True时使用无损压缩。</p></li><li><p><strong>method</strong></p><p> - 压缩速度与效率的平衡，范围0-6：</p><ul><li>值越低，压缩速度越快但文件可能更大</li><li>值越高，压缩更彻底但处理时间更长</li></ul></li><li><p><strong>target_size</strong> - 目标文件大小（字节）。</p></li><li><p><strong>target_PSNR</strong> - 目标峰值信噪比，用于在压缩过程中保持特定质量标准。</p></li><li><p><strong>exact</strong> - 是否保留图像的所有小细节，包括透明度数据。</p></li></ol><h3 id="WebP压缩的两种模式"><a href="#WebP压缩的两种模式" class="headerlink" title="WebP压缩的两种模式"></a>WebP压缩的两种模式</h3><h4 id="1-无损WebP压缩"><a href="#1-无损WebP压缩" class="headerlink" title="1. 无损WebP压缩"></a>1. 无损WebP压缩</h4><p>无损WebP压缩与PNG类似，保证图像质量不会降低：</p><ul><li>使用了改进的预测技术来编码图像</li><li>采用熵编码（一种类似于哈夫曼编码的技术）</li><li>通常比PNG文件小约26%，同时保持完全相同的图像质量</li><li>支持透明度（Alpha通道），与PNG一样</li></ul><h4 id="2-有损WebP压缩"><a href="#2-有损WebP压缩" class="headerlink" title="2. 有损WebP压缩"></a>2. 有损WebP压缩</h4><p>有损WebP压缩基于VP8视频编码：</p><ul><li>使用预测编码来创建图像的不同版本</li><li>应用量化步骤，舍弃人眼不太敏感的细节</li><li>最后应用熵编码来进一步压缩数据</li><li>通常可以比同等质量的JPEG小25-34%</li><li>也支持透明度，这是JPEG所不具备的功能</li></ul><h3 id="在PILLOW中使用WebP压缩的示例代码"><a href="#在PILLOW中使用WebP压缩的示例代码" class="headerlink" title="在PILLOW中使用WebP压缩的示例代码"></a>在PILLOW中使用WebP压缩的示例代码</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开图像</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">"input.jpg"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有损WebP压缩 (质量范围: 0-100)</span></span><br><span class="line"><span class="comment"># 质量值越低，文件越小，但图像质量越差</span></span><br><span class="line">img.save(<span class="string">"output_lossy.webp"</span>, <span class="built_in">format</span>=<span class="string">"WebP"</span>, quality=<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无损WebP压缩</span></span><br><span class="line">img.save(<span class="string">"output_lossless.webp"</span>, <span class="built_in">format</span>=<span class="string">"WebP"</span>, lossless=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有损压缩但保留透明度</span></span><br><span class="line">img.save(<span class="string">"output_transparent.webp"</span>, <span class="built_in">format</span>=<span class="string">"WebP"</span>, quality=<span class="number">80</span>, method=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高级配置 - 结合多个参数</span></span><br><span class="line">img.save(<span class="string">"output_advanced.webp"</span>, </span><br><span class="line">         <span class="built_in">format</span>=<span class="string">"WebP"</span>,</span><br><span class="line">         quality=<span class="number">85</span>,           <span class="comment"># 有损压缩的质量</span></span><br><span class="line">         method=<span class="number">6</span>,             <span class="comment"># 压缩方法 (0-6)，数值越高压缩效果越好但越慢</span></span><br><span class="line">         lossless=<span class="literal">False</span>,       <span class="comment"># 是否使用无损模式</span></span><br><span class="line">         exact=<span class="literal">False</span>)          <span class="comment"># 是否保留所有原始图像信息</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pillow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件处理3-21</title>
      <link href="/2025/03/21/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-3-21/"/>
      <url>/2025/03/21/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-3-21/</url>
      
        <content type="html"><![CDATA[<h1 id="音频压缩"><a href="#音频压缩" class="headerlink" title="音频压缩"></a>音频压缩</h1><p>acodec（audio codec）参数指定音频编解码器</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">audio_codecs = {</span><br><span class="line">    <span class="string">'libmp3lame'</span>: {</span><br><span class="line">        <span class="string">'格式'</span>: <span class="string">'MP3'</span>,</span><br><span class="line">        <span class="string">'特点'</span>: <span class="string">'最广泛使用的MP3编码器'</span>,</span><br><span class="line">        <span class="string">'用法'</span>: <span class="string">"kwargs['acodec'] = 'libmp3lame'"</span></span><br><span class="line">    },</span><br><span class="line">    </span><br><span class="line">    <span class="string">'libvorbis'</span>: {</span><br><span class="line">        <span class="string">'格式'</span>: <span class="string">'OGG Vorbis'</span>,</span><br><span class="line">        <span class="string">'特点'</span>: <span class="string">'开源的高质量编码器</span></span><br><span class="line"><span class="string">        '</span>用法<span class="string">': "kwargs['</span>acodec<span class="string">'] = '</span>libvorbis<span class="string">'"</span></span><br><span class="line"><span class="string">    },</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    '</span>aac<span class="string">': {</span></span><br><span class="line"><span class="string">        '</span>格式<span class="string">': '</span>AAC<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>特点<span class="string">': '</span>高效的有损压缩编码器<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>用法<span class="string">': "kwargs['</span>acodec<span class="string">'] = '</span>aac<span class="string">'"</span></span><br><span class="line"><span class="string">    },</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    '</span>flac<span class="string">': {</span></span><br><span class="line"><span class="string">        '</span>格式<span class="string">': '</span>FLAC<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>特点<span class="string">': '</span>无损压缩编码器<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>用法<span class="string">': "kwargs['</span>acodec<span class="string">'] = '</span>flac<span class="string">'"</span></span><br><span class="line"><span class="string">    },</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    '</span>pcm_s16le<span class="string">': {</span></span><br><span class="line"><span class="string">        '</span>格式<span class="string">': '</span>WAV<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>特点<span class="string">': '</span><span class="number">16</span>位PCM无压缩编码<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>用法<span class="string">': "kwargs['</span>acodec<span class="string">'] = '</span>pcm_s16le<span class="string">'"</span></span><br><span class="line"><span class="string">    },</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    '</span>libopus<span class="string">': {</span></span><br><span class="line"><span class="string">        '</span>格式<span class="string">': '</span>Opus<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>特点<span class="string">': '</span>新一代高效编码器，适合网络传输<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>用法<span class="string">': "kwargs['</span>acodec<span class="string">'] = '</span>libopus<span class="string">'"</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p>q:a 和 b:a 是FFmpeg中两个不同的音频编码参数，它们代表不同的控制方式：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">audio_params = {</span><br><span class="line">    <span class="string">'b:a'</span>: {</span><br><span class="line">        <span class="string">'含义'</span>: <span class="string">'音频比特率 (Bitrate)'</span>,</span><br><span class="line">        <span class="string">'单位'</span>: <span class="string">'bits/s，通常写作"128k"、"320k"等'</span>,</span><br><span class="line">        <span class="string">'控制方式'</span>: <span class="string">'直接指定输出文件的比特率'</span>,</span><br><span class="line">        <span class="string">'适用模式'</span>: <span class="string">'CBR (固定比特率)'</span>,</span><br><span class="line">        <span class="string">'示例'</span>: <span class="string">"kwargs['b:a'] = '192k'"</span></span><br><span class="line">    },</span><br><span class="line">    </span><br><span class="line">    <span class="string">'q:a'</span>: {</span><br><span class="line">        <span class="string">'含义'</span>: <span class="string">'音频质量 (Quality)'</span>,</span><br><span class="line">        <span class="string">'单位'</span>: <span class="string">'无单位的质量等级，不同编码器范围不同'</span>,</span><br><span class="line">        <span class="string">'控制方式'</span>: <span class="string">'指定质量级别，编码器自动调整比特率'</span>,</span><br><span class="line">        <span class="string">'适用模式'</span>: <span class="string">'VBR (可变比特率)'</span>,</span><br><span class="line">        <span class="string">'示例'</span>: <span class="string">"kwargs['q:a'] = 4"</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="音频转换"><a href="#音频转换" class="headerlink" title="音频转换"></a>音频转换</h1><h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><p>采样率指的是每秒捕获音频信号的次数，通常以赫兹(Hz)或千赫兹(kHz)为单位。</p><p><strong>作用和意义：</strong></p><ul><li><p><strong>决定可表现的最高频率</strong>：根据奈奎斯特定理，采样率决定了可以准确重现的最高频率（约为采样率的一半）</p></li><li><p><strong>影响音频清晰度</strong>：较高的采样率可以捕获更多细节，特别是高频细节</p></li><li><p>适用场景差异</p><p>：</p><ul><li>44.1kHz：CD标准质量，适合大多数音乐</li><li>48kHz：专业音频和视频制作标准</li><li>96kHz/192kHz：高清音频录制、专业混音</li><li>8kHz/16kHz：语音通话、语音录制</li></ul></li></ul><h3 id="声道数"><a href="#声道数" class="headerlink" title="声道数"></a>声道数</h3><p>声道数表示音频中独立音轨的数量，决定了空间音效的表现能力。</p><p><strong>作用和意义：</strong></p><ul><li><p><strong>空间定位</strong>：多声道提供更准确的声音空间定位感</p></li><li><p>常见声道配置</p><p>：</p><ul><li>单声道(Mono)：1个声道，无方向感</li><li>立体声(Stereo)：2个声道(左右)，基本的空间感</li><li>2.1声道：2个主声道+1个低音声道</li><li>5.1环绕声：5个主声道+1个低音声道，电影院标准</li><li>7.1环绕声：7个主声道+1个低音声道，高级家庭影院</li></ul></li><li><p><strong>文件大小影响</strong>：声道数越多，文件越大（线性关系）</p></li></ul><h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h3><ul><li><strong>音乐：</strong> 44.1kHz或48kHz，立体声</li><li><strong>电影/视频：</strong> 48kHz，根据内容选择多声道配置</li><li><strong>语音通话/会议：</strong> 8-16kHz，单声道</li><li><strong>专业录音：</strong> 96kHz或更高，根据需求选择声道配置</li><li><strong>空间受限设备：</strong> 可考虑降低采样率和声道数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件处理3-19</title>
      <link href="/2025/03/19/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-3-19/"/>
      <url>/2025/03/19/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-3-19/</url>
      
        <content type="html"><![CDATA[<h1 id="argparse模块使用"><a href="#argparse模块使用" class="headerlink" title="argparse模块使用"></a>argparse模块使用</h1><p>在 Python 的 <code>argparse</code> 模块中，<code>add_argument()</code> 方法是定义命令行参数的核心方法。它允许你指定参数的名称、类型、默认值、帮助信息以及参数的行为（如是否必须输入）。以下是 <code>add_argument()</code> 的详细用法和常见参数说明：</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(name_or_flags, [action], [nargs], [const], [default], [<span class="built_in">type</span>], [choices], [required], [<span class="built_in">help</span>], [metavar], [dest])</span><br></pre></td></tr></tbody></table></figure><h3 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a><strong>参数详解</strong></h3><h4 id="1-name-or-flags（参数名称-标志）"><a href="#1-name-or-flags（参数名称-标志）" class="headerlink" title="1. name_or_flags（参数名称/标志）"></a>1. <strong><code>name_or_flags</code>（参数名称/标志）</strong></h4><ul><li>定义参数的名称或标志（如 <code>-f</code> 或 <code>--file</code>）。</li><li><strong>位置参数</strong>：直接写参数名（如 <code>input_file</code>），使用时无需前缀。</li><li><strong>可选参数</strong>：以 <code>-</code>（短参数，如 <code>-f</code>）或 <code>--</code>（长参数，如 <code>--file</code>）开头。</li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位置参数（必须输入）</span></span><br><span class="line">parser.add_argument(<span class="string">"input_file"</span>, <span class="built_in">help</span>=<span class="string">"输入文件路径"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选参数（短标志和长标志）</span></span><br><span class="line">parser.add_argument(<span class="string">"-o"</span>, <span class="string">"--output"</span>, <span class="built_in">help</span>=<span class="string">"输出文件路径"</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="2-action（参数行为）"><a href="#2-action（参数行为）" class="headerlink" title="2. action（参数行为）"></a>2. <strong><code>action</code>（参数行为）</strong></h4><ul><li>指定参数的行为逻辑。常见值：<ul><li><code>"store"</code>：默认行为，存储参数的值。</li><li><code>"store_true"</code>/<code>"store_false"</code>：若参数存在，存储 <code>True</code>/<code>False</code>。</li><li><code>"append"</code>：允许多次使用参数，值存储为列表。</li><li><code>"count"</code>：统计参数出现的次数（如 <code>-vvv</code> 存储为 <code>3</code>）。</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 布尔标志（存在则为 True）</span></span><br><span class="line">parser.add_argument(<span class="string">"--verbose"</span>, <span class="string">"-v"</span>, action=<span class="string">"store_true"</span>, <span class="built_in">help</span>=<span class="string">"启用详细模式"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计参数出现次数</span></span><br><span class="line">parser.add_argument(<span class="string">"-V"</span>, <span class="string">"--verbosity"</span>, action=<span class="string">"count"</span>, default=<span class="number">0</span>, <span class="built_in">help</span>=<span class="string">"详细级别"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许多次输入（存储为列表）</span></span><br><span class="line">parser.add_argument(<span class="string">"--tag"</span>, action=<span class="string">"append"</span>, <span class="built_in">help</span>=<span class="string">"添加标签"</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="3-type（参数类型）"><a href="#3-type（参数类型）" class="headerlink" title="3. type（参数类型）"></a>3. <strong><code>type</code>（参数类型）</strong></h4><ul><li>指定参数的值的类型（如 <code>int</code>, <code>float</code>, <code>str</code> 或自定义函数）。</li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 强制转换为整数</span></span><br><span class="line">parser.add_argument(<span class="string">"--num"</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">"整数参数"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义类型（例如文件检查）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">valid_file</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(filename):</span><br><span class="line">        <span class="keyword">raise</span> argparse.ArgumentTypeError(<span class="string">f"<span class="subst">{filename}</span> 不存在"</span>)</span><br><span class="line">    <span class="keyword">return</span> filename</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">"--input"</span>, <span class="built_in">type</span>=valid_file, <span class="built_in">help</span>=<span class="string">"输入文件"</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="4-default（默认值）"><a href="#4-default（默认值）" class="headerlink" title="4. default（默认值）"></a>4. <strong><code>default</code>（默认值）</strong></h4><ul><li>当参数未输入时使用的默认值。</li><li>如果未指定，参数未输入时值为 <code>None</code>。</li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">"--port"</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">8080</span>, <span class="built_in">help</span>=<span class="string">"端口号（默认 8080）"</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="5-required（是否必须）"><a href="#5-required（是否必须）" class="headerlink" title="5. required（是否必须）"></a>5. <strong><code>required</code>（是否必须）</strong></h4><ul><li>仅对可选参数有效。若设为 <code>True</code>，则必须输入该参数。</li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">"--user"</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">"必须指定用户名"</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="6-help（帮助信息）"><a href="#6-help（帮助信息）" class="headerlink" title="6. help（帮助信息）"></a>6. <strong><code>help</code>（帮助信息）</strong></h4><ul><li>参数的描述信息，会在 <code>--help</code> 中显示。</li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">"--output"</span>, <span class="string">"-o"</span>, <span class="built_in">help</span>=<span class="string">"指定输出文件路径"</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="7-choices（可选值限制）"><a href="#7-choices（可选值限制）" class="headerlink" title="7. choices（可选值限制）"></a>7. <strong><code>choices</code>（可选值限制）</strong></h4><ul><li>限制参数的取值范围，输入值必须在 <code>choices</code> 列表中。</li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">"--color"</span>, choices=[<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>], <span class="built_in">help</span>=<span class="string">"颜色选择"</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="8-nargs（参数数量）"><a href="#8-nargs（参数数量）" class="headerlink" title="8. nargs（参数数量）"></a>8. <strong><code>nargs</code>（参数数量）</strong></h4><ul><li>指定参数接受的值数量：<ul><li><code>N</code>：接受固定数量（如 <code>nargs=2</code> 接受两个值）。</li><li><code>?</code>：接受 0 或 1 个值（通常与 <code>default</code> 配合）。</li><li><code>*</code>：接受任意数量值（存储为列表）。</li><li><code>+</code>：接受至少一个值。</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接受两个值（例如 --point 10 20）</span></span><br><span class="line">parser.add_argument(<span class="string">"--point"</span>, nargs=<span class="number">2</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">"坐标点 (x y)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受任意数量值（例如 --files a.txt b.txt）</span></span><br><span class="line">parser.add_argument(<span class="string">"--files"</span>, nargs=<span class="string">"*"</span>, <span class="built_in">help</span>=<span class="string">"文件列表"</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="9-metavar（帮助信息中的占位名）"><a href="#9-metavar（帮助信息中的占位名）" class="headerlink" title="9. metavar（帮助信息中的占位名）"></a>9. <strong><code>metavar</code>（帮助信息中的占位名）</strong></h4><ul><li>在帮助信息中替代参数的默认显示名称。</li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 帮助信息中显示为 "FILE" 而非 "input_file"</span></span><br><span class="line">parser.add_argument(<span class="string">"input_file"</span>, metavar=<span class="string">"FILE"</span>, <span class="built_in">help</span>=<span class="string">"输入文件"</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="10-dest（存储结果的属性名）"><a href="#10-dest（存储结果的属性名）" class="headerlink" title="10. dest（存储结果的属性名）"></a>10. <strong><code>dest</code>（存储结果的属性名）</strong></h4><ul><li>自定义解析后参数的属性名（默认根据参数名生成）。</li></ul><p><strong>示例</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解析后的结果存储在 args.output_file 而非 args.o</span></span><br><span class="line">parser.add_argument(<span class="string">"-o"</span>, dest=<span class="string">"output_file"</span>, <span class="built_in">help</span>=<span class="string">"输出文件"</span>)</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> argparser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件处理3.11</title>
      <link href="/2025/03/11/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-3-11/"/>
      <url>/2025/03/11/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-3-11/</url>
      
        <content type="html"><![CDATA[<h1 id="优秀的-Go-Web-项目目录结构"><a href="#优秀的-Go-Web-项目目录结构" class="headerlink" title="优秀的 Go Web 项目目录结构"></a>优秀的 Go Web 项目目录结构</h1><h4 id="Go-应用程序相关目录"><a href="#Go-应用程序相关目录" class="headerlink" title="Go 应用程序相关目录"></a>Go 应用程序相关目录</h4><h5 id="cmd"><a href="#cmd" class="headerlink" title="/cmd"></a><code>/cmd</code></h5><p>这个目录主要负责程序的启动、初始化、停止等功能，故主要包含项目的入口文件 <code>main.go</code>，如果一个项目有多个组件，则可以存放多个组件的 <code>main.go</code>，例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmd</span><br><span class="line">├── ctl</span><br><span class="line">│   └── main.go</span><br><span class="line">├── server</span><br><span class="line">│   └── main.go</span><br><span class="line">└── task</span><br><span class="line">    └── main.go</span><br></pre></td></tr></tbody></table></figure><p>不要在这个目录中放太多的代码，更不要放业务逻辑代码，保持整洁。</p><h5 id="internal"><a href="#internal" class="headerlink" title="/internal"></a><code>/internal</code></h5><p>存放项目的内部私有代码和库，不允许在项目外部使用。同时这也是 Go 在编译时强制执行的校验规则，如果在其他项目中导入 <code>internal</code> 目录下的内容，Go(1.19) 在编译时会得到如下错误：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use of internal package xxx not allowed</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注：<code>xxx</code> 为包含 <code>internal</code> 的包路径</p></blockquote><p>在项目的目录树中的任意位置都可以有 <code>internal</code> 目录，而不仅仅是在顶级目录中。</p><p>在 <code>/internal</code> 内部可以增加额外的包结构来区分组件间共享和私有的内部代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">internal</span><br><span class="line">├── app</span><br><span class="line">│   ├── ctl</span><br><span class="line">│   ├── server</span><br><span class="line">│   └── task</span><br><span class="line">└── pkg</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>/internal/app</code> 下存放各个组件的逻辑代码，<code>/internal/pkg</code> 下存放各组件间的共享代码。</p><h5 id="pkg"><a href="#pkg" class="headerlink" title="/pkg"></a><code>/pkg</code></h5><p>包含可导出的公共库，可以被其他项目引用。这意味着此目录下的代码可以被导入任何其他项目，被当作库程序来使用，所以将代码放到此目录前要慎重考虑，不要将私有代码放到此目录下。</p><p>Travis Jeffery 撰写了<a href="https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/">一篇文章</a>讲解了 <code>pkg</code> 和 <code>internal</code> 目录使用建议，你可以进一步了解学习。</p><h5 id="configs"><a href="#configs" class="headerlink" title="/configs"></a><code>/configs</code></h5><p>此目录存放配置文件模板或默认配置。</p><p>前文讲设计项目目录的基本原则时提到目录名最好使用单数形式，不过由于使用 <code>configs</code> 来存放配置已经是约定俗成的事实标准，故此目录名称可以打破这项设计原则。</p><h5 id="test"><a href="#test" class="headerlink" title="/test"></a><code>/test</code></h5><p>可以用来存放 e2e 测试和测试数据等。</p><p>对于较大的项目，有一个数据子目录更好一些。例如，如果需要 Go 在编译时忽略目录中的内容，则可以使用 <code>/test/data</code> 或 <code>/test/testdata</code> 这样的目录名称。</p><p>另外 Go 还会忽略以 <code>.</code> 或 <code>_</code> 开头的目录或文件，因此可以更具灵活性的来命名测试数据目录。</p><h5 id="deployments"><a href="#deployments" class="headerlink" title="deployments"></a><code>deployments</code></h5><p>用来存放 IaaS、PaaS 系统和容器编排部署所需要的配置及模板（如：Docker-Compose，Kubernetes/Helm，Mesos，Terraform，Bosh）。</p><p>如果你的项目作为 Kubernetes 生态中的一员或使用 Kubernetes 部署，则建议命名为 <code>/deploy</code>，更加符合 Kubernetes 社区风格。</p><h5 id="third-party"><a href="#third-party" class="headerlink" title="/third_party"></a><code>/third_party</code></h5><p>外部辅助工具目录，fork 的代码和其他第三方工具（例如 Swagger UI）。比如我们修改了某个开源的第三方项目的代码，使其满足当前项目的使用需求，就可以将修改后的代码放到 <code>/third_party/fork</code> 目录下进行维护。</p><h5 id="web"><a href="#web" class="headerlink" title="/web"></a><code>/web</code></h5><p>如果你打算在项目目录下包含配套的前端程序代码，则可以存放到此目录。主要包括静态资源、前端代码、路由等。</p><p>如果你的项目仅提供 RESTful API，且前后端程序需要分开独立维护，则可以不需要此目录，建议将前端代码作为一个独立的项目存在。</p><h4 id="项目管理相关目录"><a href="#项目管理相关目录" class="headerlink" title="项目管理相关目录"></a>项目管理相关目录</h4><h5 id="init"><a href="#init" class="headerlink" title="/init"></a><code>/init</code></h5><p>包含系统初始化（systemd、upstart、sysv）和进程管理（runit、supervisord）等配置。这在非容器化部署的项目中非常有用。</p><p>另外还可以包含初始化代码，如数据库迁移、缓存初始化等。</p><h5 id="scripts"><a href="#scripts" class="headerlink" title="/scripts"></a><code>/scripts</code></h5><p>存放用于执行各种构建、安装、分析等操作的脚本。</p><p>根文件 <code>/Makefile</code> 可以引用这些脚本，使其变得更小、更易于维护。</p><h5 id="build"><a href="#build" class="headerlink" title="/build"></a><code>/build</code></h5><p>存放程序构建和持续集成相关的文件。例如：</p><p>使用 <code>/build/package</code> 目录来存放云（AMI），容器（Docker），操作系统（deb，rpm，pkg）软件包配置和脚本。</p><p>使用 <code>/build/ci</code> 目录来存放 CI（travis、circle、drone）配置文件和脚本。</p><h5 id="tools"><a href="#tools" class="headerlink" title="/tools"></a><code>/tools</code></h5><p>此项目的支持工具。这些工具可以从 <code>/pkg</code> 和 <code>/internal</code> 目录导入代码。</p><h5 id="assets"><a href="#assets" class="headerlink" title="/assets"></a><code>/assets</code></h5><p>项目使用的其他资源 (Image、CSS、JavaScript、SQL 文件等)。</p><h5 id="githooks"><a href="#githooks" class="headerlink" title="/githooks"></a><code>/githooks</code></h5><p>Git 相关的钩子存放目录。</p><h4 id="项目文档相关目录"><a href="#项目文档相关目录" class="headerlink" title="项目文档相关目录"></a>项目文档相关目录</h4><h5 id="api"><a href="#api" class="headerlink" title="/api"></a><code>/api</code></h5><p>当前项目对外暴露的 API 文档，如 OpenAPI/Swagger 规范文档、JSON Schema 文件、ProtoBuf 定义文件等。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">api</span><br><span class="line">└── openapi</span><br><span class="line">    └── openapi.yaml</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="docs"><a href="#docs" class="headerlink" title="/docs"></a><code>/docs</code></h5><p>设计、开发和用户文档等（除 godoc 生成的文档）。</p><h5 id="examples"><a href="#examples" class="headerlink" title="/examples"></a><code>/examples</code></h5><p>应用程序或公共库的示例。降低使用者的上手难度。</p><h4 id="不建议使用的目录"><a href="#不建议使用的目录" class="headerlink" title="不建议使用的目录"></a>不建议使用的目录</h4><h5 id="src"><a href="#src" class="headerlink" title="/src"></a><code>/src</code></h5><p>一些有 Java 或 Python 开发经验的开发者习惯在项目中设计一个 <code>/src</code> 目录，但在 Go 语言中这是不推荐的做法。</p><p>早期的 Go 语言的项目都会被放置到 <code>$GOPATH/src</code> 目录下，如果项目中再有一个 <code>/src</code> 目录，那么项目最终的存放的路径就显得比较奇怪：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$GOPATH/src/your_project/src/your_code.go</span><br></pre></td></tr></tbody></table></figure><h4 id="一些放在项目根目录下的文件"><a href="#一些放在项目根目录下的文件" class="headerlink" title="一些放在项目根目录下的文件"></a>一些放在项目根目录下的文件</h4><h5 id="README-md"><a href="#README-md" class="headerlink" title="/README.md"></a><code>/README.md</code></h5><p><code>README.md</code> 是学习并使用项目的入口，是让用户了解项目的第一手资料。一个项目的 <code>README.md</code> 通常包含项目名称和简介、安装说明、使用说明、贡献方式、版权和许可等。</p><p>GitHub 也会默认解析 <code>README.md</code> 文件并渲染成 HTML 文档。</p><h5 id="Makefile"><a href="#Makefile" class="headerlink" title="/Makefile"></a><code>/Makefile</code></h5><p><code>Makefile</code> 是一个老牌的项目管理工具，建议在 Go 项目中都集成它。<code>Makefile</code> 语法可以参考 <a href="https://seisman.github.io/how-to-write-makefile/index.html">跟我一起写 Makefile </a>。</p><h5 id="CHANGELOG"><a href="#CHANGELOG" class="headerlink" title="/CHANGELOG"></a><code>/CHANGELOG</code></h5><p>用于存放项目的更新记录，如版本号、作者、更新内容等。如果嫌麻烦，还可以使用 <a href="https://github.com/git-chglog/git-chglog">git-chglog</a> 或类似工具自动生成。</p><h5 id="CONTRIBUTING-md"><a href="#CONTRIBUTING-md" class="headerlink" title="/CONTRIBUTING.md"></a><code>/CONTRIBUTING.md</code></h5><p>如果你的项目是开源项目，则建议包含 <code>/CONTRIBUTING.md</code> 文件，用来说明如何贡献代码、项目规范等，让第三方开发者更容易参与进来。</p><h5 id="LICENSE"><a href="#LICENSE" class="headerlink" title="/LICENSE"></a><code>/LICENSE</code></h5><p>开源项目一定要包含 <code>/LICENSE</code>，即开源许可证。没有开源许可证的项目，严格来讲不叫开源项目，如何选择开源许可证可以参考我的另一篇文章 <a href="https://jianghushinian.cn/2023/01/15/open-source-license-introduction/">开源协议简介</a>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过上面的讲解，最终我们得到的项目目录结构如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">├── CHANGELOG</span><br><span class="line">├── CONTRIBUTING.md</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Makefile</span><br><span class="line">├── README.md</span><br><span class="line">├── api</span><br><span class="line">│   └── openapi</span><br><span class="line">│       └── openapi.yaml</span><br><span class="line">├── assets</span><br><span class="line">├── build</span><br><span class="line">├── cmd</span><br><span class="line">│   ├── ctl</span><br><span class="line">│   │   └── main.go</span><br><span class="line">│   ├── server</span><br><span class="line">│   │   └── main.go</span><br><span class="line">│   └── task</span><br><span class="line">│       └── main.go</span><br><span class="line">├── configs</span><br><span class="line">├── deployments</span><br><span class="line">├── docs</span><br><span class="line">├── examples</span><br><span class="line">├── githooks</span><br><span class="line">├── init</span><br><span class="line">├── internal</span><br><span class="line">│   ├── app</span><br><span class="line">│   │   ├── ctl</span><br><span class="line">│   │   ├── server</span><br><span class="line">│   │   └── task</span><br><span class="line">│   └── pkg</span><br><span class="line">├── pkg</span><br><span class="line">├── scripts</span><br><span class="line">├── test</span><br><span class="line">├── third_party</span><br><span class="line">├── tools</span><br><span class="line">└── web</span><br></pre></td></tr></tbody></table></figure><p>此目录结构主要参考 <code>golang-standards/project-layout</code> 项目，和一些我自己的思考，最终总结出来。</p><p>通过使用以上提供的项目目录结构，可以帮助开发者更好地管理和组织自己的代码，提高代码的可维护性和可扩展性。</p><p>以上介绍的目录结构比较适合中大型项目，如果你的项目比较小，则可以只使用 <code>/cmd</code>、<code>/internal</code>、<code>/configs</code> 等几个少量目录，其他目录根据需要再来创建。如果你的项目足够小，甚至不需要什么目录，直接采用平铺式代码结构（将所有文件都放在项目根目录下）即可。</p><p>另外，随着技术的不断迭代发展，如 DDD 正在流行起来，Go 社区对项目目录结构的探索也仍在继续，在可预见的未来，一个优秀的 Go Web 项目目录结构的定义一定会被更新，期待下次能够分享更优秀的目录结构设计。</p><p> :) </p><h1 id="接口应用"><a href="#接口应用" class="headerlink" title="接口应用"></a>接口应用</h1><p>在Go中，接口（interface）是非常核心的特性，它为Go提供了灵活的多态支持。与其他语言不同，Go语言的接口是隐式实现的，不需要显式声明类去实现某个接口，而是通过类型实现接口的方法来隐式满足接口的要求。接口常用于以下几种场合：</p><h3 id="1-多态（Polymorphism）"><a href="#1-多态（Polymorphism）" class="headerlink" title="1. 多态（Polymorphism）"></a>1. <strong>多态（Polymorphism）</strong></h3><ul><li>Go的接口支持多态，可以通过接口类型来处理不同类型的对象。你可以定义一个接口，任何实现了这个接口方法集的类型都可以被赋值给接口类型，这样就实现了多态。</li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Speaker <span class="keyword">interface</span> {</span><br><span class="line">    Speak() <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Speak() <span class="type">string</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Speak() <span class="type">string</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Woof!"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(speaker Speaker)</span></span> {</span><br><span class="line">    fmt.Println(speaker.Speak())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    p := Person{}</span><br><span class="line">    d := Dog{}</span><br><span class="line">    say(p) <span class="comment">// Output: Hello!</span></span><br><span class="line">    say(d) <span class="comment">// Output: Woof!</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-依赖注入（Dependency-Injection）"><a href="#2-依赖注入（Dependency-Injection）" class="headerlink" title="2. 依赖注入（Dependency Injection）"></a>2. <strong>依赖注入（Dependency Injection）</strong></h3><ul><li>Go没有内建的依赖注入框架，但可以通过接口来实现依赖注入。接口让你在不依赖具体实现的情况下，将不同的服务（例如数据库、缓存等）注入到应用中。</li></ul><p><strong>示例：</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Database <span class="keyword">interface</span> {</span><br><span class="line">    Save(data <span class="type">string</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MySQLDatabase <span class="keyword">struct</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MySQLDatabase)</span></span> Save(data <span class="type">string</span>) {</span><br><span class="line">    fmt.Println(<span class="string">"Saving to MySQL:"</span>, data)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MongoDatabase <span class="keyword">struct</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MongoDatabase)</span></span> Save(data <span class="type">string</span>) {</span><br><span class="line">    fmt.Println(<span class="string">"Saving to MongoDB:"</span>, data)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> {</span><br><span class="line">    db Database</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Service)</span></span> StoreData(data <span class="type">string</span>) {</span><br><span class="line">    s.db.Save(data)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    mysql := MySQLDatabase{}</span><br><span class="line">    mongo := MongoDatabase{}</span><br><span class="line"></span><br><span class="line">    service1 := Service{db: mysql}</span><br><span class="line">    service1.StoreData(<span class="string">"User1 Data"</span>)</span><br><span class="line"></span><br><span class="line">    service2 := Service{db: mongo}</span><br><span class="line">    service2.StoreData(<span class="string">"User2 Data"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-接口作为参数和返回值"><a href="#3-接口作为参数和返回值" class="headerlink" title="3. 接口作为参数和返回值"></a>3. <strong>接口作为参数和返回值</strong></h3><ul><li>接口在函数参数和返回值中使用非常广泛，这让函数变得更加灵活，可以接受任何实现了该接口的类型。</li></ul><p><strong>示例：</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Formatter <span class="keyword">interface</span> {</span><br><span class="line">    Format() <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printFormatted</span><span class="params">(f Formatter)</span></span> {</span><br><span class="line">    fmt.Println(f.Format())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> {</span><br><span class="line">    Title <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Book)</span></span> Format() <span class="type">string</span> {</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"Book Title: %s"</span>, b.Title)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    b := Book{Title: <span class="string">"Go Programming"</span>}</span><br><span class="line">    printFormatted(b)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-动态类型（Type-Assertion）"><a href="#4-动态类型（Type-Assertion）" class="headerlink" title="4. 动态类型（Type Assertion）"></a>4. <strong>动态类型（Type Assertion）</strong></h3><ul><li>Go接口提供了类型断言（Type Assertion）功能，可以将接口类型转换为具体类型，从而可以访问接口中存储的实际类型。这在处理不同类型的对象时非常有用。</li></ul><p><strong>示例：</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>{} = <span class="number">42</span></span><br><span class="line"><span class="keyword">if</span> v, ok := i.(<span class="type">int</span>); ok {</span><br><span class="line">    fmt.Println(<span class="string">"Integer value:"</span>, v)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    fmt.Println(<span class="string">"Not an int"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-标准库的接口应用"><a href="#5-标准库的接口应用" class="headerlink" title="5. 标准库的接口应用"></a>5. <strong>标准库的接口应用</strong></h3><ul><li>Go的标准库广泛使用接口来提供灵活的功能，例如 <code>io.Reader</code> 和 <code>io.Writer</code> 接口，用于文件操作、网络传输等。这些接口可以处理任何实现了这些接口的类型。</li></ul><p><strong>示例：</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"io"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    f, err := os.Open(<span class="string">"file.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Println(<span class="string">"Error:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">var</span> buf [<span class="number">512</span>]<span class="type">byte</span></span><br><span class="line">    n, err := f.Read(buf[:])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF {</span><br><span class="line">        fmt.Println(<span class="string">"Error:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    fmt.Printf(<span class="string">"Read %d bytes: %s\n"</span>, n, <span class="type">string</span>(buf[:n]))</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="6-定义回调函数（Callback）"><a href="#6-定义回调函数（Callback）" class="headerlink" title="6. 定义回调函数（Callback）"></a>6. <strong>定义回调函数（Callback）</strong></h3><ul><li>你可以使用接口来定义回调函数，在某些事件或操作完成后，接口方法会被调用。</li></ul><p><strong>示例：</strong></p><p>​你可以使用接口来定义回调函数，在某些事件或操作完成后，接口方法会被调用。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventHandler <span class="keyword">interface</span> {</span><br><span class="line">    HandleEvent(event <span class="type">string</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Button <span class="keyword">struct</span> {</span><br><span class="line">    handler EventHandler</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Button)</span></span> OnClick() {</span><br><span class="line">    b.handler.HandleEvent(<span class="string">"Button clicked!"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ClickHandler <span class="keyword">struct</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ClickHandler)</span></span> HandleEvent(event <span class="type">string</span>) {</span><br><span class="line">    fmt.Println(<span class="string">"Event:"</span>, event)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    clickHandler := &amp;ClickHandler{}</span><br><span class="line">    button := &amp;Button{handler: clickHandler}</span><br><span class="line">    button.OnClick()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>更直观的回调函数示例</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数类型定义</span></span><br><span class="line"><span class="keyword">type</span> Callback <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processEvent</span><span class="params">(callback Callback)</span></span> {</span><br><span class="line">    <span class="comment">// 模拟事件处理，事件发生时调用回调</span></span><br><span class="line">    event := <span class="string">"Button clicked!"</span></span><br><span class="line">    callback(event)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 定义一个回调函数</span></span><br><span class="line">    myCallback := <span class="function"><span class="keyword">func</span><span class="params">(event <span class="type">string</span>)</span></span> {</span><br><span class="line">        fmt.Println(<span class="string">"Event handled:"</span>, event)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将回调函数传递给 processEvent</span></span><br><span class="line">    processEvent(myCallback)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>回调函数</strong>：是通过将一个函数作为参数传递给另一个函数，并在特定时机调用它，通常用于事件驱动的编程。</p><p><strong>接口和回调</strong>：在Go中，可以通过接口实现类似回调的效果，接口提供了抽象的方式来传递处理逻辑，而具体的实现可以在运行时灵活地指定。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Go中的接口非常灵活，它们常用于：</p><ul><li>多态（简化不同类型之间的操作）</li><li>依赖注入（解耦服务）</li><li>提高函数灵活性（作为函数参数或返回值）</li><li>动态类型处理（类型断言）</li><li>标准库接口的广泛应用（如<code>io.Reader</code>）</li><li>定义回调函数等</li></ul><h1 id="Gin-生命周期"><a href="#Gin-生命周期" class="headerlink" title="Gin-生命周期"></a>Gin-生命周期</h1><p><strong>启动 Gin 引擎</strong></p><ul><li>在 Gin 中，你通过 <code>gin.Default()</code> 或 <code>gin.New()</code> 来创建一个 Gin 引擎（<code>*gin.Engine</code>）。<code>gin.Default()</code> 会自动加载一些默认的中间件，例如日志和恢复中间件。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default() // 创建一个带默认中间件的引擎</span><br></pre></td></tr></tbody></table></figure><p><strong>路由定义</strong></p><ul><li>在 Gin 中，通过 <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> 等方法定义路由。这些路由会与特定的处理函数（也称为 Handler）绑定，用于处理相应的请求。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET("/hello", func(c *gin.Context) {</span><br><span class="line">    c.JSON(200, gin.H{"message": "Hello, world!"})</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><strong>请求到达 Gin 引擎</strong></p><ul><li>当 HTTP 请求到达 Gin 引擎时，Gin 会根据请求的 URL 和方法（GET、POST 等）找到对应的路由处理函数。</li></ul><p><strong>执行中间件</strong></p><ul><li>Gin 支持中间件，它们会在请求到达路由处理器之前或响应发回客户端之前执行。中间件是按顺序执行的，每个中间件可以执行一些前置工作（如日志记录、验证、认证、CORS 等），然后调用 <code>c.Next()</code> 或者直接结束请求处理（例如，返回响应）。</li><li>例如，Gin 默认启用了 <code>Logger</code> 中间件（记录请求日志）和 <code>Recovery</code> 中间件（处理 panic 错误）。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.Use(func(c *gin.Context) {</span><br><span class="line">    fmt.Println("Middleware before handler")</span><br><span class="line">    c.Next()</span><br><span class="line">    fmt.Println("Middleware after handler")</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><strong>执行路由处理器</strong></p><ul><li>如果请求通过所有中间件，Gin 会根据路由匹配请求，找到相应的路由处理函数（Handler）。在处理函数中，你可以访问请求数据、处理业务逻辑，并设置响应。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.GET("/user/:id", func(c *gin.Context) {</span><br><span class="line">    id := c.Param("id") // 从 URL 中提取参数</span><br><span class="line">    c.JSON(200, gin.H{"user_id": id})</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><strong>中间件执行 <code>c.Next()</code> 与 <code>c.Abort()</code></strong></p><ul><li><code>c.Next()</code>：表示继续执行后续的中间件和路由处理器。</li><li><code>c.Abort()</code>：表示中止当前请求的处理，后续的中间件和处理器将不再执行。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r.Use(func(c *gin.Context) {</span><br><span class="line">    if someCondition {</span><br><span class="line">        c.Abort() // 如果条件满足，终止请求</span><br><span class="line">        c.JSON(400, gin.H{"error": "bad request"})</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    c.Next() // 否则继续执行后续中间件</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><strong>响应构建</strong></p><ul><li>在路由处理器中，你可以设置响应的数据。例如，你可以通过 <code>c.JSON()</code>, <code>c.String()</code>, <code>c.XML()</code> 等方法来设置响应内容和 HTTP 状态码。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.JSON(200, gin.H{</span><br><span class="line">    "message": "OK",</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><strong>响应发送</strong></p><ul><li>当处理函数返回后，Gin 会把响应发送给客户端。如果没有特殊设置，Gin 会自动处理内容类型和状态码。</li></ul><p><strong>中间件后的处理</strong></p><ul><li>在请求处理完成后，任何注册在路由之后的中间件会按顺序执行。通常，这些中间件用于清理工作，如记录日志、计时、统计等。</li></ul><p><strong>应用关闭</strong></p><ul><li>当 Gin 引擎的 <code>Run()</code> 方法被调用时，它会启动一个 HTTP 服务器并监听端口。你可以使用 <code>gin.Default().Run(":8080")</code> 启动服务。你还可以根据需要优雅地关闭服务器。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if err := r.Run(":8080"); err != nil {</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Gin 也支持优雅关闭，使用 <code>context</code> 和 <code>Shutdown</code> 来处理。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server := &amp;http.Server{</span><br><span class="line">    Addr:    ":8080",</span><br><span class="line">    Handler: r,</span><br><span class="line">}</span><br><span class="line">go func() {</span><br><span class="line">    if err := server.ListenAndServe(); err != nil {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    }</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">// 优雅关闭</span><br><span class="line">quit := make(chan os.Signal, 1)</span><br><span class="line">signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">&lt;-quit</span><br><span class="line"></span><br><span class="line">if err := server.Shutdown(context.Background()); err != nil {</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go layout </tag>
            
            <tag> interface </tag>
            
            <tag> Gin生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件转换3.10</title>
      <link href="/2025/03/10/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-3-10/"/>
      <url>/2025/03/10/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-3-10/</url>
      
        <content type="html"><![CDATA[<h1 id="工作池"><a href="#工作池" class="headerlink" title="工作池"></a>工作池</h1><p><strong>工作池（Worker Pool）</strong> 是一种并发编程的设计模式，通常用于处理大量并行任务，同时通过限制并发执行的工作单元数量来有效管理系统资源。工作池的基本思想是创建多个工作线程，这些线程从任务队列中取出任务并执行，任务执行完成后返回空闲状态继续执行下一个任务。</p><h3 id="工作池的基本使用方法"><a href="#工作池的基本使用方法" class="headerlink" title="工作池的基本使用方法"></a>工作池的基本使用方法</h3><ol><li><strong>任务队列</strong>：通常，任务会被放入一个任务队列中，工作池的工作线程会从这个队列中取出任务进行处理。</li><li><strong>工作线程</strong>：工作池会初始化一定数量的工作线程，这些线程并行处理任务。线程数通常受限于系统的资源，以防止过多线程占用过多的资源。</li><li><strong>任务分发与执行</strong>：工作池从队列中取出任务并分配给空闲线程进行处理，任务执行完成后，线程会继续去队列中取任务，直到任务队列为空或所有任务完成。</li><li><strong>等待与控制</strong>：可以使用一些同步机制（如信号量、计数器、等待组等）来控制线程的启动与结束，以及等待任务的完成。</li></ol><h3 id="工作池的使用步骤（以Go语言为例）"><a href="#工作池的使用步骤（以Go语言为例）" class="headerlink" title="工作池的使用步骤（以Go语言为例）"></a>工作池的使用步骤（以Go语言为例）</h3><ol><li><p><strong>创建工作池结构</strong>：首先，定义一个工作池，池中包含多个工作线程。</p></li><li><p><strong>任务队列</strong>：任务通常会放入一个通道（channel）中，由工作线程从通道中获取任务。</p></li><li><p><strong>工作线程</strong>：每个工作线程从任务队列中获取任务并执行，执行完后继续从队列中取任务。</p></li><li><p><strong>关闭和等待</strong>：当任务处理完毕时，等待所有工作线程完成并退出。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义任务结构</span></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> {</span><br><span class="line">ID <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个工作池结构体</span></span><br><span class="line"><span class="keyword">type</span> WorkerPool <span class="keyword">struct</span> {</span><br><span class="line">TaskQueue <span class="keyword">chan</span> Task</span><br><span class="line">wg        sync.WaitGroup</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorkerPool</span><span class="params">(numWorkers <span class="type">int</span>)</span></span> *WorkerPool {</span><br><span class="line"><span class="keyword">return</span> &amp;WorkerPool{</span><br><span class="line">TaskQueue: <span class="built_in">make</span>(<span class="keyword">chan</span> Task, <span class="number">100</span>), <span class="comment">// 最大任务队列长度为100</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作线程处理任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *WorkerPool)</span></span> Worker(id <span class="type">int</span>) {</span><br><span class="line"><span class="keyword">defer</span> wp.wg.Done()</span><br><span class="line"><span class="keyword">for</span> task := <span class="keyword">range</span> wp.TaskQueue {</span><br><span class="line"><span class="comment">// 模拟任务处理</span></span><br><span class="line">fmt.Printf(<span class="string">"Worker %d is processing task %d\n"</span>, id, task.ID)</span><br><span class="line">time.Sleep(time.Second) <span class="comment">// 假设任务处理需要1秒</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动工作池</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *WorkerPool)</span></span> Start(numWorkers <span class="type">int</span>) {</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= numWorkers; i++ {</span><br><span class="line"><span class="keyword">go</span> wp.Worker(i) <span class="comment">// 启动工作线程</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务到任务队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *WorkerPool)</span></span> SubmitTask(task Task) {</span><br><span class="line">wp.TaskQueue &lt;- task</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 创建一个工作池，设置5个工作线程</span></span><br><span class="line">wp := NewWorkerPool(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动工作池</span></span><br><span class="line">wp.Start(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交10个任务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ {</span><br><span class="line">wp.SubmitTask(Task{ID: i})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待所有任务处理完成</span></span><br><span class="line">wp.wg.Add(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">close</span>(wp.TaskQueue) <span class="comment">// 关闭任务队列，通知工作线程任务完成</span></span><br><span class="line">wp.wg.Wait()        <span class="comment">// 等待所有工作线程完成</span></span><br><span class="line">fmt.Println(<span class="string">"All tasks are completed."</span>)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="上述代码的工作原理："><a href="#上述代码的工作原理：" class="headerlink" title="上述代码的工作原理："></a>上述代码的工作原理：</h3><ul><li><strong>任务队列</strong>：<code>TaskQueue</code>是一个缓冲通道，用于存储待处理的任务。</li><li><strong>工作线程</strong>：<code>Worker</code>函数模拟处理任务，每个工作线程会从<code>TaskQueue</code>中取任务，并假设每个任务处理需要1秒。</li><li><strong>启动与关闭</strong>：通过<code>Start</code>函数启动指定数量的工作线程，通过<code>SubmitTask</code>提交任务给任务队列。</li><li><strong>同步机制</strong>：<code>sync.WaitGroup</code>用于等待所有任务完成。通过<code>wp.wg.Add</code>增加等待计数，处理完一个任务后调用<code>wp.wg.Done</code>来减少计数，最后调用<code>wp.wg.Wait</code>等待所有任务完成。</li></ul></li></ol><h3 id="工作池的常见使用案例"><a href="#工作池的常见使用案例" class="headerlink" title="工作池的常见使用案例"></a>工作池的常见使用案例</h3><ol><li><strong>Web服务器</strong>：<ul><li>在高并发的Web服务器中，工作池可以用来处理来自客户端的多个并发请求。每个请求可以由一个工作线程处理，工作池管理这些工作线程的创建和任务分配。</li><li>例如，在电商网站的支付系统中，每当有用户发起支付请求时，系统可以使用工作池来分配处理任务，如验证支付信息、调用支付接口等。</li></ul></li><li><strong>数据处理与分析</strong>：<ul><li>在大数据处理场景中，工作池可以用来并行处理数据。比如，在数据导入、数据清洗和分析时，工作池可以并发执行多个任务，快速完成数据处理工作。</li><li>比如，假设有大量的文件需要处理，工作池可以分配多个工作线程，分别处理不同的文件，缩短整体处理时间。</li></ul></li><li><strong>异步任务处理</strong>：<ul><li>对于异步任务处理，工作池常常用于调度任务的执行。例如，某些系统可能会有定时任务或批处理任务，需要通过工作池来管理这些任务的并发执行。</li><li>比如，定时任务执行日志清理、定期发送邮件等操作。</li></ul></li><li><strong>图像处理</strong>：<ul><li>对于大量的图像或视频数据处理（如图像转码、视频编辑等），工作池可以用来并行处理每一帧或每一张图片。每个工作线程可以处理一部分数据，最终合并结果。</li><li>比如，在图像上传时，工作池可以处理多张图片的缩放、裁剪、滤镜等操作。</li></ul></li></ol><h1 id="Go语言中的var关键字和星号-的含义"><a href="#Go语言中的var关键字和星号-的含义" class="headerlink" title="Go语言中的var关键字和星号*的含义"></a>Go语言中的var关键字和星号*的含义</h1><p>指针类型声明：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var executor *PythonExecutor</span><br></pre></td></tr></tbody></table></figure><p>这表示executor是一个指向PythonExecutor类型的指针，而不是PythonExecutor类型的值。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value := *executor  *// 获取指针指向的值*</span><br></pre></td></tr></tbody></table></figure><p>这会获取指针指向的实际值。</p><h1 id="Go语言中的return语句解析"><a href="#Go语言中的return语句解析" class="headerlink" title="Go语言中的return语句解析"></a>Go语言中的return语句解析</h1><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultConfig</span><span class="params">()</span></span> TaskManagerConfig {</span><br><span class="line">    <span class="keyword">return</span> TaskManagerConfig{</span><br><span class="line">        WorkersPerProcessor: <span class="number">5</span>,</span><br><span class="line">        QueueSize:           <span class="number">100</span>,</span><br><span class="line">        TaskTimeout:         <span class="number">30</span> * time.Minute,</span><br><span class="line">        CleanupInterval:     <span class="number">1</span> * time.Hour,</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里的return语句有以下特点：</p><p>直接返回初始化的结构体：函数创建并初始化了一个TaskManagerConfig结构体，然后立即返回它</p><p>无需临时变量：不需要先声明一个变量，再给它赋值，最后返回它，而是一步完成</p><p>简洁写法：这是Go中常见的简洁写法，特别适合返回简单初始化的值</p><p>函数即表达式：这种写法体现了Go中”函数即表达式”的理念</p><h1 id="time-Duration"><a href="#time-Duration" class="headerlink" title="time.Duration"></a>time.Duration</h1><p>time.Duration 是 Go 语言标准库中的一个类型，用于表示时间间隔。它实际上是一个 int64 类型的别名，表示纳秒数</p><h1 id="sync-waitgroup"><a href="#sync-waitgroup" class="headerlink" title="sync waitgroup"></a>sync waitgroup</h1><p><code>waitGroup</code> ，也是在go语言并发中比较常用的语法，所以在这里我们一起剖析 waitGroup 的使用方式及其源码解读。</p><p><code>WaitGroup</code> 也是sync 包下一份子，用来解决任务编排的一个并发原语。它主要解决了并发-等待问题：比如现在有三个<code>goroutine</code>，分别为<code>goroutineA</code>，<code>goroutineB</code>，<code>goroutineC</code>，而<code>goroutineA</code>需要等待<code>goroutineB</code>和<code>goroutineC</code>这一组goroutine全部执行完毕后，才可以执行后续业务逻辑。此时就可以使用 <code>WaitGroup</code> 轻松解决。</p><p>在这个场景中，<code>goroutineA</code>为主goroutine，<code>goroutineB</code>和<code>goroutineC</code>为子goroutine。<code>goroutineA</code>则需要在<strong>检查点(checkout point)</strong> 等待<code>goroutineB</code>和<code>goroutineC</code>全部执行完毕，如果在执行任务的<code>goroutine</code>还没全部完成，那么<code>goroutineA</code>就会阻塞在检查点，直到所有<code>goroutine</code>都完成后才能继续执行。</p><p><strong>代码实现：</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutineB</span><span class="params">(wg *sync.WaitGroup)</span></span> {</span><br><span class="line">            </span><br><span class="line">  <span class="keyword">defer</span> wg.Done()</span><br><span class="line">  fmt.Println(<span class="string">"goroutineB Execute"</span>)</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutineC</span><span class="params">(wg *sync.WaitGroup)</span></span> {</span><br><span class="line">            </span><br><span class="line">  <span class="keyword">defer</span> wg.Done()</span><br><span class="line">  fmt.Println(<span class="string">"goroutineC Execute"</span>)</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">            </span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">go</span> goroutineB(&amp;wg)</span><br><span class="line">  <span class="keyword">go</span> goroutineC(&amp;wg)</span><br><span class="line">  wg.Wait()</span><br><span class="line">  fmt.Println(<span class="string">"goroutineB and goroutineC finished..."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>运行结果:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">goroutineC Execute</span><br><span class="line">goroutineB Execute</span><br><span class="line">goroutineB and goroutineC finished...</span><br></pre></td></tr></tbody></table></figure><p>上述就是<strong>WaitGroup</strong> 的简单操作，它的语法也是比较简单，提供了三个方法，如下所示：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait()</span><br></pre></td></tr></tbody></table></figure><ul><li>Add：用来设置WaitGroup的计数值(子goroutine的数量)</li><li>Done：用来将WaitGroup的计数值减1，起始就是调用Add(-1)</li><li>Wait：调用这个方法的goroutine会一直阻塞，直到WaitGroup的技术值变为0</li></ul><p>接下来，我们进行剖析 WaitGroup 的源码实现，让其无处可遁，它源码比较少，除去注释，也就几十行，对新手来说也是一种不错的选择。</p><h2 id="WaitGroup的实现"><a href="#WaitGroup的实现" class="headerlink" title="WaitGroup的实现"></a>WaitGroup的实现</h2><p>首先，我们看看 WaitGroup 的数据结构，它包括了一个noCopy 的辅助字段，一个具有复合意义的state1字段。</p><ul><li>noCopy 的辅助字段：主要就是辅助 vet 工具检查是否通过 copy 赋值这个 WaitGroup 实例。我会在后面和你详细分析这个字段</li><li>state1：具有复合意义的字段，包含WaitGroup计数值，阻塞在检查点的主gooutine和信号量</li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> {</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 避免复制使用的一个技巧，可以告诉vet工具违反了复制使用的规则</span></span><br><span class="line">    noCopy noCopy</span><br><span class="line">    <span class="comment">// 64bit(8bytes)的值分成两段，高32bit是计数值，低32bit是waiter的计数</span></span><br><span class="line">    <span class="comment">// 另外32bit是用作信号量的</span></span><br><span class="line">    <span class="comment">// 因为64bit值的原子操作需要64bit对齐，但是32bit编译器不支持，所以数组中的元素在不同的架构中不一样，具体处理看下面的方法</span></span><br><span class="line">    <span class="comment">// 总之，会找到对齐的那64bit作为state，其余的32bit做信号量</span></span><br><span class="line">    state1 [<span class="number">3</span>]<span class="type">uint32</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到state的地址和信号量的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> state() (statep *<span class="type">uint64</span>, semap *<span class="type">uint32</span>) {</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> {</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 如果地址是64bit对齐的，数组前两个元素做state，后一个元素做信号量</span></span><br><span class="line">        <span class="keyword">return</span> (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="number">2</span>]</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 如果地址是32bit对齐的，数组后两个元素用来做state，它可以用来做64bit的原子操作，第一个元素32bit用来做信号量</span></span><br><span class="line">        <span class="keyword">return</span> (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), &amp;wg.state1[<span class="number">0</span>]</span><br><span class="line">    }</span><br><span class="line">}    </span><br></pre></td></tr></tbody></table></figure><p>因为对 64 位整数的原子操作要求整数的地址是 64 位对齐的，所以针对 64 位和 32 位环境的 state 字段的组成是不一样的。</p><p>在 64 位环境下，state1 的第一个元素是 waiter 数，第二个元素是 WaitGroup 的计数值，第三个元素是信号量。</p><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p><strong>Add方法实现思路：</strong></p><p>Add方法主要操作的state1字段中计数值部分。当Add方法被调用时，首先会将delta参数值左移32位(计数值在高32位)，然后内部通过原子操作将这个值加到计数值上。需要注意的是，delta的取值范围可正可负，因为调用Done()方法时，内部通过Add(-1)方法实现的。</p><p><strong>代码实现如下：</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>) {</span><br><span class="line">            </span><br><span class="line">  <span class="comment">// statep表示wait数和计数值</span></span><br><span class="line">  <span class="comment">// 低32位表示wait数，高32位表示计数值</span></span><br><span class="line">   statep, semap := wg.state()</span><br><span class="line">   <span class="comment">// uint64(delta)&lt;&lt;32 将delta左移32位</span></span><br><span class="line">    <span class="comment">// 因为高32位表示计数值，所以将delta左移32，增加到技术上</span></span><br><span class="line">   state := atomic.AddUint64(statep, <span class="type">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">   <span class="comment">// 当前计数值</span></span><br><span class="line">   v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">   <span class="comment">// 阻塞在检查点的wait数</span></span><br><span class="line">   w := <span class="type">uint32</span>(state)</span><br><span class="line">   <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> {</span><br><span class="line">            </span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   }</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 如果计数值v为0并且waiter的数量w不为0，那么state的值就是waiter的数量</span></span><br><span class="line">    <span class="comment">// 将waiter的数量设置为0，因为计数值v也是0,所以它们俩的组合*statep直接设置为0即可。此时需要并唤醒所有的waiter</span></span><br><span class="line">   *statep = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- {</span><br><span class="line">            </span><br><span class="line">      runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h3><p>内部就是调用Add(-1)方法，这里就不细讲了。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Done方法实际就是计数器减1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done() {</span><br><span class="line">             </span><br><span class="line">  wg.Add(<span class="number">-1</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h3><p><strong>wait实现思路：</strong></p><p>不断检查state值。如果其中的计数值为零，则说明所有的子goroutine已全部执行完毕，调用者不必等待，直接返回。如果计数值大于零，说明此时还有任务没有完成，那么调用者变成等待者，需要加入wait队列，并且阻塞自己。</p><p><strong>代码实现如下：</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait() {</span><br><span class="line">            </span><br><span class="line">   <span class="comment">// statep表示wait数和计数值</span></span><br><span class="line">   <span class="comment">// 低32位表示wait数，高32位表示计数值</span></span><br><span class="line">   statep, semap := wg.state()</span><br><span class="line">   <span class="keyword">for</span> {</span><br><span class="line">            </span><br><span class="line">      state := atomic.LoadUint64(statep)</span><br><span class="line">      <span class="comment">// 将state右移32位，表示当前计数值</span></span><br><span class="line">      v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">      <span class="comment">// w表示waiter等待值</span></span><br><span class="line">      w := <span class="type">uint32</span>(state)</span><br><span class="line">      <span class="keyword">if</span> v == <span class="number">0</span> {</span><br><span class="line">            </span><br><span class="line">         <span class="comment">// 如果当前计数值为零，表示当前子goroutine已全部执行完毕，则直接返回</span></span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 否则使用原子操作将state值加一。</span></span><br><span class="line">      <span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) {</span><br><span class="line">            </span><br><span class="line">         <span class="comment">// 阻塞休眠等待</span></span><br><span class="line">         runtime_Semacquire(semap)</span><br><span class="line">         <span class="comment">// 被唤醒，不再阻塞，返回</span></span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作池 </tag>
            
            <tag> return结构体 </tag>
            
            <tag> Duration </tag>
            
            <tag> sync waitgroup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件处理3-7</title>
      <link href="/2025/03/07/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-3-7/"/>
      <url>/2025/03/07/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-3-7/</url>
      
        <content type="html"><![CDATA[<h2 id="interface-的用法"><a href="#interface-的用法" class="headerlink" title="[]interface{}的用法"></a>[]interface{}的用法</h2><p><code>[]interface{}</code> 是 Go 语言中的一种切片类型，它表示一个 <strong>空接口切片</strong>。让我们逐步解析这个类型：</p><ol><li>**<code>interface{}</code>**：这是 Go 中的 <strong>空接口</strong> 类型，表示没有任何方法的接口类型。实际上，在 Go 中，所有类型都实现了空接口类型，所以空接口可以用来存储任何类型的值。因此，<code>interface{}</code> 是一个可以容纳任何类型的万能容器。</li><li>**<code>[]interface{}</code>**：这表示一个由空接口类型元素构成的 <strong>切片</strong>。由于空接口可以容纳任何类型的值，<code>[]interface{}</code> 就是一个可以容纳任意类型元素的切片。通过这种方式，你可以创建一个切片，其中的元素类型可以是任意类型的值。</li></ol><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 创建一个空接口切片，可以存储不同类型的元素</span></span><br><span class="line">    <span class="keyword">var</span> items []<span class="keyword">interface</span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向切片中添加不同类型的数据</span></span><br><span class="line">    items = <span class="built_in">append</span>(items, <span class="number">42</span>)        <span class="comment">// 整数</span></span><br><span class="line">    items = <span class="built_in">append</span>(items, <span class="string">"hello"</span>)   <span class="comment">// 字符串</span></span><br><span class="line">    items = <span class="built_in">append</span>(items, <span class="number">3.14</span>)      <span class="comment">// 浮点数</span></span><br><span class="line">    items = <span class="built_in">append</span>(items, <span class="literal">true</span>)      <span class="comment">// 布尔值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历切片并使用类型断言</span></span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items {</span><br><span class="line">        <span class="keyword">switch</span> v := item.(<span class="keyword">type</span>) {</span><br><span class="line">        <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">            fmt.Println(<span class="string">"Integer:"</span>, v)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">            fmt.Println(<span class="string">"String:"</span>, v)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">            fmt.Println(<span class="string">"Float:"</span>, v)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">            fmt.Println(<span class="string">"Boolean:"</span>, v)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"Unknown type"</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interface用法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件处理3-5</title>
      <link href="/2025/03/05/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-3-5/"/>
      <url>/2025/03/05/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-3-5/</url>
      
        <content type="html"><![CDATA[<h2 id="file-header-err-c-Request-FormFile-“file”"><a href="#file-header-err-c-Request-FormFile-“file”" class="headerlink" title="file, header, err := c.Request.FormFile(“file”)"></a>file, header, err := c.Request.FormFile(“file”)</h2><h2 id="paramsJSON-err-json-Marshal-params"><a href="#paramsJSON-err-json-Marshal-params" class="headerlink" title="paramsJSON, err := json.Marshal(params)"></a>paramsJSON, err := json.Marshal(params)</h2><p>paramsJSON, err := json.Marshal(params) 的效果。这个函数将 Go 的数据结构转换为 JSON 字符串。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">params := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"张三"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="string">"isStudent"</span>: <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">paramsJSON, err := json.Marshal(params)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">    fmt.Println(<span class="string">"转换错误:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="type">string</span>(paramsJSON))</span><br><span class="line"><span class="comment">// 输出: {"age":25,"isStudent":true,"name":"张三"}</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">params := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">    <span class="string">"user"</span>: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"李四"</span>,</span><br><span class="line">        <span class="string">"contacts"</span>: []<span class="type">string</span>{<span class="string">"13800138000"</span>, <span class="string">"13900139000"</span>},</span><br><span class="line">        <span class="string">"address"</span>: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>{</span><br><span class="line">            <span class="string">"city"</span>: <span class="string">"北京"</span>,</span><br><span class="line">            <span class="string">"street"</span>: <span class="string">"朝阳区"</span></span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">    <span class="string">"timestamp"</span>: time.Now()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">paramsJSON, err := json.Marshal(params)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">    fmt.Println(<span class="string">"转换错误:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="type">string</span>(paramsJSON))</span><br><span class="line"><span class="comment">// 输出: {"timestamp":"2024-03-05T14:30:00+08:00","user":{"address":{"city":"北京","street":"朝阳区"},"contacts":["13800138000","13900139000"],"name":"李四"}}</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">params := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">    <span class="string">"file_id"</span>: <span class="string">"doc123"</span>,</span><br><span class="line">    <span class="string">"operation"</span>: <span class="string">"compress"</span>,</span><br><span class="line">    <span class="string">"options"</span>: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">        <span class="string">"quality"</span>: <span class="number">80</span>,</span><br><span class="line">        <span class="string">"format"</span>: <span class="string">"pdf"</span>,</span><br><span class="line">        <span class="string">"pages"</span>: []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>},</span><br><span class="line">        <span class="string">"settings"</span>: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>{</span><br><span class="line">            <span class="string">"keepMetadata"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"fastCompression"</span>: <span class="literal">false</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">paramsJSON, err := json.Marshal(params)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">    fmt.Println(<span class="string">"转换错误:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="type">string</span>(paramsJSON))</span><br><span class="line"><span class="comment">// 输出: {"file_id":"doc123","operation":"compress","options":{"format":"pdf","keepMetadata":true,"fastCompression":false,"pages":[1,2,3],"quality":80}}</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件转换3.3</title>
      <link href="/2025/03/03/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-3-3/"/>
      <url>/2025/03/03/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-3-3/</url>
      
        <content type="html"><![CDATA[<h2 id="go-sync-map-的使用"><a href="#go-sync-map-的使用" class="headerlink" title="go sync.map 的使用"></a>go sync.map 的使用</h2><p>无须初始化，直接声明即可。<br>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load 表示获取，Delete 表示删除。<br>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，Range 参数中回调函数的返回值在需要继续迭代遍历时，返回 true，终止迭代遍历时，返回 false。</p><p><strong>sync.Map提供的常用方法有如下七个</strong>:</p><ul><li>Load(key interface{}) (value interface{},ok bool)：通过参数key查询对应的value，如果不存在则返回nil；ok表示是否找到对应的值。</li><li>Store(key,value interface{})：该方法相当于对sync.Map的更新或新增，参数是键值对。</li><li>LoadOrStore(key,value interface{}) (actual interface{},loaded bool)：该方法的参数为key和value。该方法会先根据参数key查找对应的value，如果找到则不修改原来的值并通过actual返回，并且loaded为true；如果通过key无法查找到对应的value，则存储key-value并且将存储的value通过actual返回，loaded为false。</li><li>Delete(key interface{})：通过key删除键值对。</li><li>LoadAndDelete(key interface{})：通过key删除键的值，如果有，则返回上一个值。</li><li>Range(f func(key,value interface{}) bool)：遍历sync.Map的元素，注意for…range map是对内置map类型的用法，sync.Map需要使用单独的Range方法。</li></ul><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明sync.Map</span></span><br><span class="line"><span class="keyword">var</span> syncmap sync.Map</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Store方法将键值对保存到sync.Map</span></span><br><span class="line">    syncmap.Store(<span class="string">"zhangsan"</span>, <span class="number">97</span>)</span><br><span class="line">    syncmap.Store(<span class="string">"lisi"</span>, <span class="number">100</span>)</span><br><span class="line">    syncmap.Store(<span class="string">"wangmazi"</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoadOrStore key不存在</span></span><br><span class="line">    v, ok := syncmap.LoadOrStore(<span class="number">3</span>, <span class="string">"three"</span>)</span><br><span class="line">    fmt.Println(v, ok) <span class="comment">// three false</span></span><br><span class="line">    <span class="comment">// LoadOrStore key存在</span></span><br><span class="line">    v, ok = syncmap.LoadOrStore(<span class="number">1</span>, <span class="string">"thisOne"</span>)</span><br><span class="line">    fmt.Println(v, ok) <span class="comment">// one ture</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load方法获取sync.Map 键所对应的值</span></span><br><span class="line">    fmt.Println(syncmap.Load(<span class="string">"lisi"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete方法键删除对应的键值对</span></span><br><span class="line">    syncmap.Delete(<span class="string">"lisi"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> syncmap sync.Map</span><br><span class="line">    <span class="comment">// LoadAndDelete key不存在</span></span><br><span class="line">    v, ok := syncmap.LoadAndDelete(<span class="string">"xiaomi"</span>)</span><br><span class="line">    fmt.Println(v, ok) <span class="comment">// &lt;nil&gt; false</span></span><br><span class="line">    syncmap.Store(<span class="string">"xiaomi"</span>, <span class="string">"xiaomi"</span>)</span><br><span class="line">    <span class="comment">// LoadAndDelete key存在</span></span><br><span class="line">    v, ok = syncmap.LoadAndDelete(<span class="string">"xiaomi"</span>)</span><br><span class="line">    fmt.Println(v, ok) <span class="comment">// xiaomi true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Range遍历所有sync.Map中的键值对</span></span><br><span class="line">    syncmap.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>{})</span></span> <span class="type">bool</span> {</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>声明 score，类型为 sync.Map，注意，sync.Map 不能使用 make 创建。</p><p>将一系列键值对保存到 sync.Map 中，sync.Map 将键和值以 interface{} 类型进行保存。</p><p>Range() 方法可以遍历 sync.Map，遍历需要提供一个匿名函数，参数为 k、v，类型为 interface{}，每次 Range() 在遍历一个元素时，都会调用这个匿名函数把结果返回。</p><p>sync.Map 没有提供获取 map 数量的方法，替代方法是在获取 sync.Map 时遍历自行计算数量，sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</p><h2 id="go语言接口"><a href="#go语言接口" class="headerlink" title="go语言接口"></a>go语言接口</h2><p>接口（interface）是 Go 语言中的一种<strong>类型</strong>，用于定义行为的集合，它通过描述类型必须实现的方法，规定了类型的行为契约。</p><p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p><p>Go 的接口设计简单却功能强大，是实现多态和解耦的重要工具。</p><p>接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。</p><h3 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h3><p><strong>隐式实现</strong>：</p><ul><li>Go 中没有关键字显式声明某个类型实现了某个接口。</li><li>只要一个类型实现了接口要求的所有方法，该类型就自动被认为实现了该接口。</li></ul><p><strong>接口类型变量</strong>：</p><ul><li>接口变量可以存储实现该接口的任意值。</li><li>接口变量实际上包含了两个部分：<ul><li><strong>动态类型</strong>：存储实际的值类型。</li><li><strong>动态值</strong>：存储具体的值。</li></ul></li></ul><p><strong>零值接口</strong>：</p><ul><li>接口的零值是 <code>nil</code>。</li><li>一个未初始化的接口变量其值为 <code>nil</code>，且不包含任何动态类型或值。</li></ul><p><strong>空接口</strong>：</p><ul><li>定义为 <code>interface{}</code>，可以表示任何类型。</li></ul><h3 id="接口的常见用法"><a href="#接口的常见用法" class="headerlink" title="接口的常见用法"></a>接口的常见用法</h3><ol><li><strong>多态</strong>：不同类型实现同一接口，实现多态行为。</li><li><strong>解耦</strong>：通过接口定义依赖关系，降低模块之间的耦合。</li><li><strong>泛化</strong>：使用空接口 <code>interface{}</code> 表示任意类型。</li></ol><h2 id="接口定义和实现"><a href="#接口定义和实现" class="headerlink" title="接口定义和实现"></a>接口定义和实现</h2><p>接口定义使用关键字 <strong>interface</strong>，其中包含方法声明。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义接口 */</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> {</span><br><span class="line">   method_name1 [return_type]</span><br><span class="line">   method_name2 [return_type]</span><br><span class="line">   method_name3 [return_type]</span><br><span class="line">   ...</span><br><span class="line">   method_namen [return_type]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> {</span><br><span class="line">   <span class="comment">/* variables */</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现接口方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span></span> method_name1() [return_type] {</span><br><span class="line">   <span class="comment">/* 方法实现 */</span></span><br><span class="line">}</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span></span> method_namen() [return_type] {</span><br><span class="line">   <span class="comment">/* 方法实现*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><p>空接口 <code>interface{}</code> 是 Go 的特殊接口，表示所有类型的超集。</p><ul><li>任意类型都实现了空接口。</li><li>常用于需要存储任意类型数据的场景，如泛型容器、通用参数等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> go sync.map </tag>
            
            <tag> go接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件转换2.28</title>
      <link href="/2025/02/28/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-2-28/"/>
      <url>/2025/02/28/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-2-28/</url>
      
        <content type="html"><![CDATA[<h1 id="golang的yaml解析"><a href="#golang的yaml解析" class="headerlink" title="golang的yaml解析"></a>golang的yaml解析</h1><p>先写yaml文件，再定义储存yaml文件的结构体，然后声明全局变量GlobalConfig来储存yaml文件中的数据。</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> config</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"gopkg.in/yaml.v3"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> {</span><br><span class="line">Server <span class="keyword">struct</span> {</span><br><span class="line">Host <span class="type">string</span> <span class="string">`yaml:"host"`</span></span><br><span class="line">Port <span class="type">int</span>    <span class="string">`yaml:"port"`</span></span><br><span class="line">} <span class="string">`yaml:"server"`</span></span><br><span class="line"></span><br><span class="line">FileStorage <span class="keyword">struct</span> {</span><br><span class="line">Path <span class="type">string</span> <span class="string">`yaml:"path"`</span></span><br><span class="line">} <span class="string">`yaml:"file_storage"`</span></span><br><span class="line"></span><br><span class="line">Python <span class="keyword">struct</span> {</span><br><span class="line">EnvPath    <span class="type">string</span> <span class="string">`yaml:"env_path"`</span></span><br><span class="line">ScriptsDir <span class="type">string</span> <span class="string">`yaml:"scripts_dir"`</span></span><br><span class="line">} <span class="string">`yaml:"python"`</span></span><br><span class="line"></span><br><span class="line">Redis <span class="keyword">struct</span> {</span><br><span class="line">Host         <span class="type">string</span> <span class="string">`yaml:"host"`</span></span><br><span class="line">Port         <span class="type">int</span>    <span class="string">`yaml:"port"`</span></span><br><span class="line">Password     <span class="type">string</span> <span class="string">`yaml:"password"`</span></span><br><span class="line">DB           <span class="type">int</span>    <span class="string">`yaml:"db"`</span></span><br><span class="line">PoolSize     <span class="type">int</span>    <span class="string">`yaml:"pool_size"`</span></span><br><span class="line">MinIdleConns <span class="type">int</span>    <span class="string">`yaml:"min_idle_conns"`</span></span><br><span class="line">MaxRetries   <span class="type">int</span>    <span class="string">`yaml:"max_retries"`</span></span><br><span class="line">Timeout      <span class="type">int</span>    <span class="string">`yaml:"timeout"`</span></span><br><span class="line">} <span class="string">`yaml:"redis"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> GlobalConfig Config<span class="comment">// 定义一个全局变量来存储配置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadConfig</span><span class="params">(path <span class="type">string</span>)</span></span> <span class="type">error</span> {</span><br><span class="line">data, err := os.ReadFile(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> yaml.Unmarshal(data, &amp;GlobalConfig)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="Go语言标准库学习之os-exec——执行系统命令"><a href="#Go语言标准库学习之os-exec——执行系统命令" class="headerlink" title="Go语言标准库学习之os/exec——执行系统命令"></a>Go语言标准库学习之os/exec——执行系统命令</h1><p>os/exec包提供了执行外部命令的方法，它包装了os.StartProcess函数以便更容易的修正输入和输出，使用管道连接I/O，以及作其它的一些调整。这里记录以下os/eexec包的学习笔记，希望对你有帮助。</p><h5 id="1-执行外部命令"><a href="#1-执行外部命令" class="headerlink" title="1. 执行外部命令"></a>1. 执行外部命令</h5><p>Cmd对象：</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cmd <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// Path是将要执行的命令的路径。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 该字段不能为空，如为相对路径会相对于Dir字段。</span></span><br><span class="line">    Path <span class="type">string</span></span><br><span class="line">    <span class="comment">// Args保管命令的参数，包括命令名作为第一个参数；如果为空切片或者nil，相当于无参数命令。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 典型用法下，Path和Args都应被Command函数设定。</span></span><br><span class="line">    Args []<span class="type">string</span></span><br><span class="line">    <span class="comment">// Env指定进程的环境，如为nil，则是在当前进程的环境下执行。</span></span><br><span class="line">    Env []<span class="type">string</span></span><br><span class="line">    <span class="comment">// Dir指定命令的工作目录。如为空字符串，会在调用者的进程当前目录下执行。</span></span><br><span class="line">    Dir <span class="type">string</span></span><br><span class="line">    <span class="comment">// Stdin指定进程的标准输入，如为nil，进程会从空设备读取（os.DevNull）</span></span><br><span class="line">    Stdin io.Reader</span><br><span class="line">    <span class="comment">// Stdout和Stderr指定进程的标准输出和标准错误输出。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果任一个为nil，Run方法会将对应的文件描述符关联到空设备（os.DevNull）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果两个字段相同，同一时间最多有一个线程可以写入。</span></span><br><span class="line">    Stdout io.Writer</span><br><span class="line">    Stderr io.Writer</span><br><span class="line">    <span class="comment">// ExtraFiles指定额外被新进程继承的已打开文件流，不包括标准输入、标准输出、标准错误输出。</span></span><br><span class="line">    <span class="comment">// 如果本字段非nil，entry i会变成文件描述符3+i。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// <span class="doctag">BUG:</span> 在OS X 10.6系统中，子进程可能会继承不期望的文件描述符。</span></span><br><span class="line">    <span class="comment">// http://golang.org/issue/2603</span></span><br><span class="line">    ExtraFiles []*os.File</span><br><span class="line">    <span class="comment">// SysProcAttr保管可选的、各操作系统特定的sys执行属性。</span></span><br><span class="line">    <span class="comment">// Run方法会将它作为os.ProcAttr的Sys字段传递给os.StartProcess函数。</span></span><br><span class="line">    SysProcAttr *syscall.SysProcAttr</span><br><span class="line">    <span class="comment">// Process是底层的，只执行一次的进程。</span></span><br><span class="line">    Process *os.Process</span><br><span class="line">    <span class="comment">// ProcessState包含一个已经存在的进程的信息，只有在调用Wait或Run后才可用。</span></span><br><span class="line">    ProcessState *os.ProcessState</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>Cmd代表一个正在准备或者在执行中的外部命令。</p><p>go通过命令行调用python写好的代码示例</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"os/exec"</span></span><br><span class="line"><span class="string">"path/filepath"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// OCRResult 表示OCR识别的结果</span></span><br><span class="line"><span class="keyword">type</span> OCRResult <span class="keyword">struct</span> {</span><br><span class="line">Status  <span class="type">string</span> <span class="string">`json:"status"`</span></span><br><span class="line">Message <span class="type">string</span> <span class="string">`json:"message"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// OCR 执行OCR识别</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OCR</span><span class="params">(inputPath <span class="type">string</span>, lang <span class="type">string</span>, outputPath <span class="type">string</span>, useDoubleColumn <span class="type">bool</span>, pageRange <span class="type">string</span>)</span></span> <span class="type">error</span> {</span><br><span class="line"><span class="comment">// 构建命令参数</span></span><br><span class="line">args := []<span class="type">string</span>{<span class="string">"ocr.py"</span>, <span class="string">"ocr"</span>, inputPath}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> outputPath != <span class="string">""</span> {</span><br><span class="line">args = <span class="built_in">append</span>(args, <span class="string">"-o"</span>, outputPath)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> lang != <span class="string">""</span> {</span><br><span class="line">args = <span class="built_in">append</span>(args, <span class="string">"--lang"</span>, lang)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> pageRange != <span class="string">""</span> {</span><br><span class="line">args = <span class="built_in">append</span>(args, <span class="string">"--range"</span>, pageRange)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> useDoubleColumn {</span><br><span class="line">args = <span class="built_in">append</span>(args, <span class="string">"--use-double-column"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行命令</span></span><br><span class="line">cmd := exec.Command(<span class="string">"python"</span>, args...)</span><br><span class="line"><span class="comment">// 捕获标准输出和错误输出</span></span><br><span class="line">output, err := cmd.CombinedOutput()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"执行OCR失败: %v\n输出: %s"</span>, err, <span class="type">string</span>(output))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取结果文件</span></span><br><span class="line">homeDir, err := os.UserHomeDir()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"获取用户目录失败: %v"</span>, err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">resultPath := filepath.Join(homeDir, <span class="string">".pdf_guru"</span>, <span class="string">"cmd_output.json"</span>)</span><br><span class="line">data, err := os.ReadFile(resultPath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"读取结果文件失败: %v"</span>, err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result OCRResult</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"解析结果失败: %v"</span>, err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Status != <span class="string">"success"</span> {</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"OCR失败: %s"</span>, result.Message)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExtractBookmark 提取PDF文档的书签</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExtractBookmark</span><span class="params">(inputPath <span class="type">string</span>, lang <span class="type">string</span>, useDoubleColumn <span class="type">bool</span>, pageRange <span class="type">string</span>, outputPath <span class="type">string</span>)</span></span> <span class="type">error</span> {</span><br><span class="line">args := []<span class="type">string</span>{<span class="string">"ocr.py"</span>, <span class="string">"bookmark"</span>, inputPath}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> lang != <span class="string">""</span> {</span><br><span class="line">args = <span class="built_in">append</span>(args, <span class="string">"-l"</span>, lang)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> useDoubleColumn {</span><br><span class="line">args = <span class="built_in">append</span>(args, <span class="string">"-d"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> pageRange != <span class="string">""</span> {</span><br><span class="line">args = <span class="built_in">append</span>(args, <span class="string">"-r"</span>, pageRange)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> outputPath != <span class="string">""</span> {</span><br><span class="line">args = <span class="built_in">append</span>(args, <span class="string">"-o"</span>, outputPath)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cmd := exec.Command(<span class="string">"python"</span>, args...)</span><br><span class="line"><span class="comment">// 捕获标准输出和错误输出</span></span><br><span class="line">output, err := cmd.CombinedOutput()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"提取书签失败: %v\n输出: %s"</span>, err, <span class="type">string</span>(output))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取结果</span></span><br><span class="line">homeDir, err := os.UserHomeDir()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"获取用户目录失败: %v"</span>, err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">resultPath := filepath.Join(homeDir, <span class="string">".pdf_guru"</span>, <span class="string">"cmd_output.json"</span>)</span><br><span class="line">data, err := os.ReadFile(resultPath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"读取结果文件失败: %v"</span>, err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result OCRResult</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"解析结果失败: %v"</span>, err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Status != <span class="string">"success"</span> {</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"提取书签失败: %s"</span>, result.Message)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// OCR示例</span></span><br><span class="line">err := OCR(</span><br><span class="line"><span class="string">"test.pdf"</span>, <span class="comment">// 输入文件路径</span></span><br><span class="line"><span class="string">"ch"</span>,       <span class="comment">// 语言</span></span><br><span class="line"><span class="string">"output"</span>,   <span class="comment">// 输出路径</span></span><br><span class="line"><span class="literal">false</span>,      <span class="comment">// 是否双栏</span></span><br><span class="line"><span class="string">"1-10"</span>,     <span class="comment">// 页码范围</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"OCR错误: %v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="string">"OCR完成"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取书签示例</span></span><br><span class="line">err = ExtractBookmark(</span><br><span class="line"><span class="string">"test.pdf"</span>,   <span class="comment">// 输入文件路径</span></span><br><span class="line"><span class="string">"ch"</span>,         <span class="comment">// 语言</span></span><br><span class="line"><span class="literal">false</span>,        <span class="comment">// 是否双栏</span></span><br><span class="line"><span class="string">"1-10"</span>,       <span class="comment">// 页码范围</span></span><br><span class="line"><span class="string">"output.pdf"</span>, <span class="comment">// 输出路径</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"提取书签错误: %v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="string">"提取书签完成"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>append(args, “-o”, outputPath) 是 Go 语言中用于向切片（slice）添加元素的内置函数。语法为：</strong></p><p>append: Go的内置函数</p><p>args: 目标切片</p><p>-o 和 outputPath: 要添加的元素</p><p>=: 将新的切片赋值回 args</p><p><strong>cmd := exec.Command(“python”, args…) 是 Go 语言中用于创建外部命令的代码。</strong></p><p><strong>output, err := cmd.CombinedOutput() 用于执行命令并获取命令的输出。</strong></p><p><strong>homeDir, err := os.UserHomeDir() 是用来获取当前用户的主目录（Home Directory）路径的代码。</strong></p><p><strong>Command</strong></p><p>一般的，应该通过 <code>exec.Command</code> 函数产生 <code>Cmd</code> 实例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Command(name string, arg ...string) *Cmd</span><br></pre></td></tr></tbody></table></figure><p>该函数返回一个 <code>*Cmd</code>，用于使用给出的参数执行 <code>name</code> 指定的程序。返回的 <code>*Cmd</code> 只设定了 <code>Path</code> 和 <code>Args</code> 两个字段。</p><p>如果 <code>name</code> 不含路径分隔符，将使用 <code>LookPath</code> 获取完整路径；否则直接使用 <code>name</code>。参数 <code>arg</code> 不应包含命令名。</p><p>得到 <code>*Cmd</code> 实例后，接下来一般有两种写法：</p><ol><li>调用 <code>Start()</code>，接着调用 <code>Wait()</code>，然后会阻塞直到命令执行完成；</li><li>调用 <code>Run()</code>，它内部会先调用 <code>Start()</code>，接着调用 <code>Wait()</code>；</li></ol><p><strong>Start</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (c *Cmd) Start() error</span><br></pre></td></tr></tbody></table></figure><p>开始执行 <code>c</code> 包含的命令，但并不会等待该命令完成即返回。<code>Wait</code> 方法会返回命令的退出状态码并在命令执行完后释放相关的资源。内部调用 <code>os.StartProcess</code>，执行 <code>forkExec</code>。</p><p><strong>Wait</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (c *Cmd) Wait() error</span><br></pre></td></tr></tbody></table></figure><p><code>Wait</code> 会阻塞直到该命令执行完成，该命令必须是先通过 <code>Start</code> 执行。</p><p>如果命令成功执行，stdin、stdout、stderr 数据传递没有问题，并且返回状态码为 0，方法的返回值为 nil；如果命令没有执行或者执行失败，会返回 <code>*ExitError</code> 类型的错误；否则返回的 error 可能是表示 I/O 问题。</p><p>如果 <code>c.Stdin</code> 不是 <code>*os.File</code> 类型，<code>Wait</code> 会等待，直到数据从 <code>c.Stdin</code> 拷贝到进程的标准输入。</p><p><code>Wait</code> 方法会在命令返回后释放相关的资源。</p><p><strong>Output</strong></p><p>除了 <code>Run()</code> 是 <code>Start</code>+<code>Wait</code> 的简便写法，<code>Output()</code> 更是 <code>Run()</code> 的简便写法，外加获取外部命令的输出。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (c *Cmd) Output() ([]byte, error)</span><br></pre></td></tr></tbody></table></figure><p>它要求 <code>c.Stdout</code> 必须是 <code>nil</code>，内部会将 <code>bytes.Buffer</code> 赋值给 <code>c.Stdout</code>，在 <code>Run()</code> 成功返回后，会将 <code>Buffer</code> 的结果返回（<code>stdout.Bytes()</code>)。</p><p><strong>CombinedOutput</strong></p><p><code>Output()</code> 只返回 <code>Stdout</code> 的结果，而 <code>CombinedOutput</code> 组合 <code>Stdout</code> 和 <code>Stderr</code> 的输出，即 <code>Stdout</code> 和 <code>Stderr</code> 都赋值为同一个 <code>bytes.Buffer</code>。</p><p><strong>StdoutPipe、StderrPipe 和 StdinPipe</strong></p><p>除了上面介绍的 <code>Output</code> 和 <code>CombinedOutput</code> 直接获取命令输出结果外，还可以通过 <code>StdoutPipe</code> 返回 <code>io.ReadCloser</code> 来获取输出；相应的 <code>StderrPipe</code> 得到错误信息；而 <code>StdinPipe</code> 则可以往命令写入数据。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (c *Cmd) StdoutPipe() (io.ReadCloser, error)</span><br></pre></td></tr></tbody></table></figure><p><code>StdoutPipe</code> 方法返回一个在命令 <code>Start</code> 执行后与命令标准输出关联的管道。<code>Wait</code> 方法会在命令结束后会关闭这个管道，所以一般不需要手动关闭该管道。但是在从管道读取完全部数据之前调用 <code>Wait</code> 出错了，则必须手动关闭。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (c *Cmd) StderrPipe() (io.ReadCloser, error)</span><br></pre></td></tr></tbody></table></figure><p><code>StderrPipe</code> 方法返回一个在命令 <code>Start</code> 执行后与命令标准错误输出关联的管道。<code>Wait</code> 方法会在命令结束后会关闭这个管道，一般不需要手动关闭该管道。但是在从管道读取完全部数据之前调用 <code>Wait</code> 出错了，则必须手动关闭。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (c *Cmd) StdinPipe() (io.WriteCloser, error)</span><br></pre></td></tr></tbody></table></figure><p><code>StdinPipe</code> 方法返回一个在命令 <code>Start</code> 执行后与命令标准输入关联的管道。<code>Wait</code> 方法会在命令结束后会关闭这个管道。必要时调用者可以调用 <code>Close</code> 方法来强行关闭管道。例如，标准输入已经关闭了，命令执行才完成，这时调用者需要显示关闭管道。</p><p>因为 <code>Wait</code> 之后，会将管道关闭，所以，要使用这些方法，只能使用 <code>Start</code>+<code>Wait</code> 组合，不能使用 <code>Run</code>。</p><h3 id="执行外部命令示例"><a href="#执行外部命令示例" class="headerlink" title="执行外部命令示例"></a>执行外部命令示例</h3><p>前面讲到，通过 <code>Cmd</code> 实例后，有两种方式运行命令。有时候，我们不只是简单的运行命令，还希望能控制命令的输入和输出。通过上面的 API 介绍，控制输入输出有几种方法：</p><ul><li>得到 <code>Cmd</code> 实例后，直接给它的字段 <code>Stdin</code>、<code>Stdout</code> 和 <code>Stderr</code> 赋值；</li><li>通过 <code>Output</code> 或 <code>CombinedOutput</code> 获得输出；</li><li>通过带 <code>Pipe</code> 后缀的方法获得管道，用于输入或输出；</li></ul><h4 id="直接赋值-Stdin、Stdout-和-Stderr"><a href="#直接赋值-Stdin、Stdout-和-Stderr" class="headerlink" title="直接赋值 Stdin、Stdout 和 Stderr"></a>直接赋值 <code>Stdin</code>、<code>Stdout</code> 和 <code>Stderr</code></h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FillStd</span><span class="params">(name <span class="type">string</span>, arg ...<span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) {</span><br><span class="line">    cmd := exec.Command(name, arg...)</span><br><span class="line">    <span class="keyword">var</span> out = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line"></span><br><span class="line">    cmd.Stdout = out</span><br><span class="line">    cmd.Stderr = out</span><br><span class="line"></span><br><span class="line">    err := cmd.Run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out.Bytes(), <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-Output"><a href="#使用-Output" class="headerlink" title="使用 Output"></a>使用 <code>Output</code></h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UseOutput</span><span class="params">(name <span class="type">string</span>, arg ...<span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) {</span><br><span class="line">    <span class="keyword">return</span> exec.Command(name, arg...).Output()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-Pipe"><a href="#使用-Pipe" class="headerlink" title="使用 Pipe"></a>使用 Pipe</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UsePipe</span><span class="params">(name <span class="type">string</span>, arg ...<span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) {</span><br><span class="line">    cmd := exec.Command(name, arg...)</span><br><span class="line">    stdout, err := cmd.StdoutPipe()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = cmd.Start(); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> out = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, <span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        tmp := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>)</span><br><span class="line">        n, err := stdout.Read(tmp)</span><br><span class="line">        out = <span class="built_in">append</span>(out, tmp[:n]...)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = cmd.Wait(); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th align="center">场景</th><th align="center">推荐方案</th></tr></thead><tbody><tr><td align="center">单次脚本调用</td><td align="center"><code>os/exec</code>命令行调用</td></tr><tr><td align="center">高频低延迟调用</td><td align="center">CGO嵌入或go-python库</td></tr><tr><td align="center">分布式/微服务架构</td><td align="center">gRPC或Sidecar模式</td></tr><tr><td align="center">长期维护与性能优化</td><td align="center">代码转译或手动重写</td></tr></tbody></table><p>Go与Python的协同开发方案选择。</p><h1 id="go-python-库使用详解"><a href="#go-python-库使用详解" class="headerlink" title="go-python 库使用详解"></a>go-python 库使用详解</h1><p>初始化Python解释器：通过调用python.Initialize()函数初始化Python解释器。</p><p>在Python中定义函数：使用python.RunString()函数在Python中定义一个名为add的函数，用于计算两个数的和。</p><p>在Go中调用Python函数：使用python.PyDict_GetItemString()函数获取Python中定义的add函数，然后使用python.PyObject_CallFunction()函数调用该函数，并传递参数3和5，最后通过python.PyInt_AsLong()函数获取返回值，并打印结果。</p>]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> os/exec </tag>
            
            <tag> go-python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件转换2.26</title>
      <link href="/2025/02/26/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-2-26/"/>
      <url>/2025/02/26/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-2-26/</url>
      
        <content type="html"><![CDATA[<h2 id="pdf转excel"><a href="#pdf转excel" class="headerlink" title="pdf转excel"></a>pdf转excel</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert_pdf_excel</span>(<span class="params">doc_path: <span class="built_in">str</span>, use_ocr: <span class="built_in">bool</span> = <span class="literal">False</span>, output_path: <span class="built_in">str</span> = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">"""将PDF转换为Excel，每页PDF作为图片插入Excel</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        doc_path: 输入PDF路径</span></span><br><span class="line"><span class="string">        use_ocr: 是否对图片使用OCR识别，默认False</span></span><br><span class="line"><span class="string">        output_path: 输出Excel路径，默认为None时自动生成</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> output_path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            output_path = os.path.splitext(doc_path)[<span class="number">0</span>] + <span class="string">".xlsx"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果启用OCR，导入所需库</span></span><br><span class="line">        <span class="keyword">if</span> use_ocr:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">from</span> paddleocr <span class="keyword">import</span> PaddleOCR</span><br><span class="line">                ocr = PaddleOCR(use_angle_cls=<span class="literal">True</span>, lang=<span class="string">"ch"</span>, show_log=<span class="literal">False</span>)</span><br><span class="line">            <span class="keyword">except</span> ImportError:</span><br><span class="line">                logger.warning(<span class="string">"未安装PaddleOCR，将不使用OCR功能"</span>)</span><br><span class="line">                use_ocr = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        doc = fitz.<span class="built_in">open</span>(doc_path)</span><br><span class="line">        wb = Workbook()</span><br><span class="line">        ws = wb.active</span><br><span class="line">        </span><br><span class="line">        ws.column_dimensions[<span class="string">'A'</span>].width = <span class="number">60</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> page_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(doc)):</span><br><span class="line">            page = doc[page_num]</span><br><span class="line">            text = page.get_text()</span><br><span class="line">            clean_text = <span class="string">''</span>.join(ch <span class="keyword">for</span> ch <span class="keyword">in</span> text <span class="keyword">if</span> ch.isprintable() <span class="keyword">and</span> <span class="built_in">ord</span>(ch) &lt; <span class="number">65535</span>)</span><br><span class="line">            <span class="keyword">if</span> clean_text:</span><br><span class="line">                ws.row_dimensions[count].height = <span class="number">100</span></span><br><span class="line">                ws[<span class="string">f'A<span class="subst">{count}</span>'</span>] = clean_text</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            images = page.get_images(full=<span class="literal">True</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> images:  </span><br><span class="line">                <span class="keyword">for</span> img_index, img_info <span class="keyword">in</span> <span class="built_in">enumerate</span>(images):</span><br><span class="line">                    xref = img_info[<span class="number">0</span>]  </span><br><span class="line">                    </span><br><span class="line">                    base_image = doc.extract_image(xref)</span><br><span class="line">                    img_data = base_image[<span class="string">"image"</span>]</span><br><span class="line">                    </span><br><span class="line">                    img_byte_arr = BytesIO(img_data)</span><br><span class="line">                    </span><br><span class="line">                    img_obj = Image(img_byte_arr)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> img_obj.width &gt; <span class="number">450</span>:</span><br><span class="line">                        <span class="comment"># 保持宽高比</span></span><br><span class="line">                        ratio = img_obj.height / img_obj.width</span><br><span class="line">                        img_obj.width = <span class="number">450</span></span><br><span class="line">                        img_obj.height = <span class="built_in">int</span>(<span class="number">450</span> * ratio)</span><br><span class="line">                    </span><br><span class="line">                    ws.row_dimensions[count].height = img_obj.height</span><br><span class="line">                    </span><br><span class="line">                    ws.add_image(img_obj, <span class="string">f'A<span class="subst">{count}</span>'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> use_ocr:</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            <span class="comment"># 将图片数据转换为字节流供OCR使用</span></span><br><span class="line">                            img_byte_arr.seek(<span class="number">0</span>)</span><br><span class="line">                            result = ocr.ocr(img_byte_arr.read())</span><br><span class="line">                            <span class="keyword">if</span> result <span class="keyword">and</span> result[<span class="number">0</span>]:</span><br><span class="line">                                <span class="comment"># 提取识别文本</span></span><br><span class="line">                                ocr_text = <span class="string">'\n'</span>.join([line[<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">for</span> line <span class="keyword">in</span> result[<span class="number">0</span>] <span class="keyword">if</span> line[<span class="number">1</span>][<span class="number">0</span>].strip()])</span><br><span class="line">                                <span class="keyword">if</span> ocr_text:</span><br><span class="line">                                    ws[<span class="string">f'A<span class="subst">{count}</span>'</span>] = ocr_text</span><br><span class="line">                        <span class="keyword">except</span> Exception <span class="keyword">as</span> ocr_err:</span><br><span class="line">                            logger.warning(<span class="string">f"OCR识别失败: <span class="subst">{<span class="built_in">str</span>(ocr_err)}</span>"</span>)</span><br><span class="line"></span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        wb.save(output_path)</span><br><span class="line">        logger.info(<span class="string">f"转换成功，文件保存为: <span class="subst">{output_path}</span>"</span>)</span><br><span class="line">        utils.dump_json(cmd_output_path, {<span class="string">"status"</span>: <span class="string">"success"</span>, <span class="string">"message"</span>: <span class="string">"转换完成"</span>})</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        error_msg = traceback.format_exc()</span><br><span class="line">        logger.error(<span class="string">f"转换失败: <span class="subst">{error_msg}</span>"</span>)</span><br><span class="line">        utils.dump_json(cmd_output_path, {<span class="string">"status"</span>: <span class="string">"error"</span>, <span class="string">"message"</span>: <span class="built_in">str</span>(e)})</span><br></pre></td></tr></tbody></table></figure><h2 id="ocr提取pdf信息"><a href="#ocr提取pdf信息" class="headerlink" title="ocr提取pdf信息"></a>ocr提取pdf信息</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ocr_from_pdf</span>(<span class="params">input_path: <span class="built_in">str</span>, page_range: <span class="built_in">str</span> = <span class="string">'all'</span>, lang: <span class="built_in">str</span> = <span class="string">'ch'</span>, output_path: <span class="built_in">str</span> = <span class="literal">None</span>, offset: <span class="built_in">float</span> = <span class="number">5.</span>, use_double_columns: <span class="built_in">bool</span> = <span class="literal">False</span></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        doc: fitz.Document = fitz.<span class="built_in">open</span>(input_path)</span><br><span class="line">        p = Path(input_path)</span><br><span class="line">        <span class="keyword">if</span> output_path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            output_path = p.parent / <span class="string">f"<span class="subst">{p.stem}</span>-OCR识别"</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> output_path.exists():</span><br><span class="line">                output_path.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logger.warning(<span class="string">f"文件夹 <span class="subst">{output_path}</span> 已存在，将被删除"</span>)</span><br><span class="line">                shutil.rmtree(output_path)</span><br><span class="line">                output_path.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output_path = Path(output_path)</span><br><span class="line">            output_path.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">            </span><br><span class="line">        roi_indices = parse_range(page_range, doc.page_count)</span><br><span class="line">        <span class="keyword">if</span> lang == <span class="string">'ch'</span>:</span><br><span class="line">            ocr_engine = ocr_engine_ch</span><br><span class="line">        <span class="keyword">elif</span> lang == <span class="string">'en'</span>:</span><br><span class="line">            ocr_engine = ocr_engine_en</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"不支持的语言"</span>)</span><br><span class="line">            </span><br><span class="line">        dpi = <span class="number">300</span></span><br><span class="line">        <span class="keyword">for</span> page_index <span class="keyword">in</span> tqdm(roi_indices):</span><br><span class="line">            page = doc[page_index]</span><br><span class="line">            pix = page.get_pixmap(matrix=fitz.Matrix(dpi/<span class="number">72</span>, dpi/<span class="number">72</span>))</span><br><span class="line">            img = np.frombuffer(pix.samples, dtype=np.uint8).reshape((pix.height, pix.width, pix.n))</span><br><span class="line">            cur_output_path = output_path / <span class="string">f"<span class="subst">{page_index+<span class="number">1</span>}</span>-OCR.txt"</span></span><br><span class="line">            result = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> use_double_columns:</span><br><span class="line">                height, width = img.shape[:<span class="number">2</span>]</span><br><span class="line">                mid = width / <span class="number">2</span></span><br><span class="line">                left_img = img[:, :<span class="built_in">int</span>(mid)]</span><br><span class="line">                right_img = img[:, <span class="built_in">int</span>(mid):]</span><br><span class="line">                left_result = ocr_engine.ocr(left_img, cls=<span class="literal">False</span>)[<span class="number">0</span>]</span><br><span class="line">                right_result = ocr_engine.ocr(right_img, cls=<span class="literal">False</span>)[<span class="number">0</span>]</span><br><span class="line">                write_ocr_result(left_result, cur_output_path, offset)</span><br><span class="line">                write_ocr_result(right_result, cur_output_path, offset, mode=<span class="string">"a"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = ocr_engine.ocr(img, cls=<span class="literal">False</span>)[<span class="number">0</span>]</span><br><span class="line">                write_ocr_result(result, cur_output_path, offset)</span><br><span class="line">        path_list = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x.endswith(<span class="string">".txt"</span>), os.listdir(output_path))), key=<span class="keyword">lambda</span> x: <span class="built_in">int</span>(re.search(<span class="string">r"(\d+)"</span>, x).group(<span class="number">1</span>)))</span><br><span class="line">        merged_path = output_path / <span class="string">"合并.txt"</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(merged_path, <span class="string">"a"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> path <span class="keyword">in</span> path_list:</span><br><span class="line">                abs_path = os.path.join(output_path, path)</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(abs_path, <span class="string">"r"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f2:</span><br><span class="line">                    <span class="keyword">for</span> line <span class="keyword">in</span> f2:</span><br><span class="line">                        f.write(line)</span><br><span class="line">        </span><br><span class="line">        dump_json(cmd_output_path, {<span class="string">"status"</span>: <span class="string">"success"</span>, <span class="string">"message"</span>: <span class="string">""</span>})</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(traceback.format_exc())</span><br><span class="line">        dump_json(cmd_output_path, {<span class="string">"status"</span>: <span class="string">"error"</span>, <span class="string">"message"</span>: traceback.format_exc()})</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paddelocr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件转换2.25</title>
      <link href="/2025/02/25/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-2-25/"/>
      <url>/2025/02/25/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-2-25/</url>
      
        <content type="html"><![CDATA[<h2 id="wm-doc-fitz-open-“pdf”-pdf-buffer-read"><a href="#wm-doc-fitz-open-“pdf”-pdf-buffer-read" class="headerlink" title="wm_doc = fitz.open(“pdf”, pdf_buffer.read())"></a>wm_doc = fitz.open(“pdf”, pdf_buffer.read())</h2><p>这行代码使用 fitz 库（即 PyMuPDF）从一个缓冲区（pdf_buffer）中读取 PDF 数据，并创建一个 PDF 文档对象 wm_doc。</p><p><strong>fitz.open 函数的用法</strong>：</p><ul><li>fitz 是 PyMuPDF 库的常用别名，用于处理 PDF 文件。</li><li>fitz.open(filetype, stream)是fitz库中用于打开 PDF 文件的函数，其中：<ul><li>filetype：指定文件类型，在这里是 “pdf”，表示处理的是 PDF 文件。</li><li>stream：可以是字节对象（bytes）或具有 read() 方法的文件类对象（file-like object）。</li></ul></li><li>在代码中，pdf_buffer.read() 返回字节数据，fitz.open(“pdf”, pdf_buffer.read()) 将这些字节数据作为 PDF 文件内容打开。</li></ul><p><strong>pdf_buffer 的类型</strong>：</p><ul><li>从代码中可以看到，pdf_buffer 是一个文件类对象（例如 BytesIO），因为它支持 read() 方法。</li><li>pdf_buffer.read() 会读取缓冲区的全部内容并返回字节数据。</li></ul><p><strong>生成的 wm_doc</strong>：</p><ul><li><p>wm_doc 是通过 fitz.open 创建的 fitz.Document 对象，表示一个 PDF 文档。</p></li><li><p>这个对象可以用于后续操作，例如读取 PDF 内容、修改 PDF 或提取文本等。</p></li></ul><h2 id="PDF-文档结构"><a href="#PDF-文档结构" class="headerlink" title="PDF 文档结构"></a>PDF 文档结构</h2><p>PDF 文件由多个对象组成，包括：</p><ul><li><strong>页面对象</strong>：定义页面的属性和内容。</li><li><strong>内容流（Content Stream）</strong>：包含绘制页面内容的指令，例如文本、图像或图形。</li></ul><p>当添加水印时，代码实际上是将水印的绘制指令写入目标页面的内容流中。</p><p>第一串代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">watermark_pdf_by_image</span>(<span class="params">doc_path: <span class="built_in">str</span>, wm_path: <span class="built_in">str</span>, page_range: <span class="built_in">str</span> = <span class="string">"all"</span>, layer: <span class="built_in">str</span> = <span class="string">"bottom"</span>, output_path: <span class="built_in">str</span> = <span class="literal">None</span>, **args</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        doc = fitz.<span class="built_in">open</span>(doc_path)</span><br><span class="line">        page = doc[-<span class="number">1</span>]</span><br><span class="line">        p = Path(doc_path)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用命令行传入的 wm_path，而不是 args 中的</span></span><br><span class="line">        watermark_path = args.get(<span class="string">'wm_path'</span>) <span class="keyword">or</span> wm_path  <span class="comment"># 确保使用正确的水印路径</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> watermark_path:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"未指定水印图片路径"</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 检查文件是否存在</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> Path(watermark_path).exists():</span><br><span class="line">            <span class="keyword">raise</span> FileNotFoundError(<span class="string">f"水印图片文件不存在: <span class="subst">{watermark_path}</span>"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用 BytesIO 创建内存中的 PDF</span></span><br><span class="line">        <span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">        pdf_buffer = BytesIO()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建水印 PDF</span></span><br><span class="line">        c = canvas.Canvas(pdf_buffer, pagesize=(page.rect.width, page.rect.height))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取图片尺寸和缩放比例</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(watermark_path)</span><br><span class="line">        img_width, img_height = img.size</span><br><span class="line">        scale = args.get(<span class="string">'scale'</span>, <span class="number">1.0</span>)</span><br><span class="line">        opacity = args.get(<span class="string">'opacity'</span>, <span class="number">0.5</span>)</span><br><span class="line">        angle = args.get(<span class="string">'angle'</span>, <span class="number">0</span>)</span><br><span class="line">        x_offset = args.get(<span class="string">'x_offset'</span>, <span class="number">0</span>)</span><br><span class="line">        y_offset = args.get(<span class="string">'y_offset'</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算缩放后的尺寸</span></span><br><span class="line">        scaled_w, scaled_h = img_width * scale, img_height * scale</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置透明度</span></span><br><span class="line">        c.setFillAlpha(opacity)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 移动到页面中心并旋转</span></span><br><span class="line">        c.translate(page.rect.width/<span class="number">2</span>, page.rect.height/<span class="number">2</span>)</span><br><span class="line">        c.rotate(angle)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> args.get(<span class="string">'multiple_mode'</span>, <span class="literal">False</span>):</span><br><span class="line">            num_lines = args.get(<span class="string">'num_lines'</span>, <span class="number">1</span>)</span><br><span class="line">            line_spacing = args.get(<span class="string">'line_spacing'</span>, <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_lines):</span><br><span class="line">                y_pos = (i - num_lines/<span class="number">2</span>) * line_spacing * scaled_h</span><br><span class="line">                c.drawImage(watermark_path, -scaled_w/<span class="number">2</span> + x_offset, -scaled_h/<span class="number">2</span> + y_pos + y_offset, </span><br><span class="line">                          width=scaled_w, height=scaled_h, mask=<span class="string">'auto'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c.drawImage(watermark_path, -scaled_w/<span class="number">2</span> + x_offset, -scaled_h/<span class="number">2</span> + y_offset, </span><br><span class="line">                       width=scaled_w, height=scaled_h, mask=<span class="string">'auto'</span>)</span><br><span class="line">        </span><br><span class="line">        c.showPage()</span><br><span class="line">        c.save()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从 buffer 创建水印 PDF</span></span><br><span class="line">        pdf_buffer.seek(<span class="number">0</span>)</span><br><span class="line">        wm_doc = fitz.<span class="built_in">open</span>(<span class="string">"pdf"</span>, pdf_buffer.read())</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 应用水印</span></span><br><span class="line">        roi_indices = utils.parse_range(page_range, doc.page_count)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> roi_indices:</span><br><span class="line">            page = doc[i]</span><br><span class="line">            overlay = <span class="literal">False</span> <span class="keyword">if</span> layer == <span class="string">"bottom"</span> <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line">            page.show_pdf_page(page.rect, wm_doc, <span class="number">0</span>, overlay=overlay)</span><br><span class="line">            page.clean_contents()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 保存结果</span></span><br><span class="line">        <span class="keyword">if</span> output_path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            output_path = <span class="built_in">str</span>(p.parent / <span class="string">f"<span class="subst">{p.stem}</span>-加水印版.pdf"</span>)</span><br><span class="line">        doc.save(output_path, garbage=<span class="number">3</span>, deflate=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 关闭文档</span></span><br><span class="line">        wm_doc.close()</span><br><span class="line">        doc.close()</span><br><span class="line">        pdf_buffer.close()</span><br><span class="line">        </span><br><span class="line">        utils.dump_json(cmd_output_path, {<span class="string">"status"</span>: <span class="string">"success"</span>, <span class="string">"message"</span>: <span class="string">""</span>})</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(traceback.format_exc())</span><br><span class="line">        utils.dump_json(cmd_output_path, {<span class="string">"status"</span>: <span class="string">"error"</span>, <span class="string">"message"</span>: <span class="built_in">str</span>(e)})</span><br></pre></td></tr></tbody></table></figure><p>第二串代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">watermark_pdf_by_text</span>(<span class="params"></span></span><br><span class="line"><span class="params">    doc_path: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    wm_text: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    page_range: <span class="built_in">str</span> = <span class="string">"all"</span>,</span></span><br><span class="line"><span class="params">    layer: <span class="built_in">str</span> = <span class="string">"top"</span>,</span></span><br><span class="line"><span class="params">    output_path: <span class="built_in">str</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    font: <span class="built_in">str</span> = <span class="string">"msyh.ttc"</span>,</span></span><br><span class="line"><span class="params">    fontsize: <span class="built_in">float</span> = <span class="number">30</span>,</span></span><br><span class="line"><span class="params">    angle: <span class="built_in">float</span> = <span class="number">45</span>,</span></span><br><span class="line"><span class="params">    text_stroke_color_rgb: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>] = (<span class="params"><span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span></span>),  <span class="comment"># 灰色描边</span></span></span><br><span class="line"><span class="params">    text_fill_color_rgb: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>] = (<span class="params"><span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span></span>),    <span class="comment"># 灰色填充</span></span></span><br><span class="line"><span class="params">    opacity: <span class="built_in">float</span> = <span class="number">1</span>,</span></span><br><span class="line"><span class="params">    num_lines: <span class="built_in">int</span> = <span class="number">1</span>,</span></span><br><span class="line"><span class="params">    line_spacing: <span class="built_in">float</span> = <span class="number">2</span>,</span></span><br><span class="line"><span class="params">    word_spacing: <span class="built_in">float</span> = <span class="number">2</span>,</span></span><br><span class="line"><span class="params">    multiple_mode: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    x_offset: <span class="built_in">float</span> = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">    y_offset: <span class="built_in">float</span> = <span class="number">0</span></span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 打开原始 PDF</span></span><br><span class="line">        doc = fitz.<span class="built_in">open</span>(doc_path)</span><br><span class="line">        roi_indices = utils.parse_range(page_range, doc.page_count)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 存储不同页面尺寸的水印文档</span></span><br><span class="line">        wm_docs = {}</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理每页的水印</span></span><br><span class="line">        <span class="keyword">for</span> page_index <span class="keyword">in</span> roi_indices:</span><br><span class="line">            page = doc[page_index]</span><br><span class="line">            size = (page.rect.width, page.rect.height)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果该尺寸的水印尚未创建，则创建新的水印文档</span></span><br><span class="line">            <span class="keyword">if</span> size <span class="keyword">not</span> <span class="keyword">in</span> wm_docs:</span><br><span class="line">                wm_doc = fitz.<span class="built_in">open</span>()  <span class="comment"># 在内存中创建新 PDF</span></span><br><span class="line">                wm_page = wm_doc.new_page(width=size[<span class="number">0</span>], height=size[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 加载字体</span></span><br><span class="line">                fontname = utils.load_font(wm_doc, font)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 创建 Shape 对象</span></span><br><span class="line">                shape = wm_page.new_shape()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 设置填充颜色（RGB 转换为浮点数）</span></span><br><span class="line">                r, g, b = [x/<span class="number">255.0</span> <span class="keyword">for</span> x <span class="keyword">in</span> text_fill_color_rgb]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 计算文本宽度</span></span><br><span class="line">                text_width = fitz.get_text_length(wm_text, fontname=fontname, fontsize=fontsize)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 计算中心点</span></span><br><span class="line">                center_x = size[<span class="number">0</span>] / <span class="number">2</span></span><br><span class="line">                center_y = size[<span class="number">1</span>] / <span class="number">2</span></span><br><span class="line">                center_point = fitz.Point(center_x, center_y)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 创建旋转矩阵（仅旋转，不包含平移）</span></span><br><span class="line">                angle_rad = math.radians(angle)  <span class="comment"># 转换为弧度</span></span><br><span class="line">                cos_angle = math.cos(angle_rad)</span><br><span class="line">                sin_angle = math.sin(angle_rad)</span><br><span class="line">                rotation_matrix = fitz.Matrix(cos_angle, -sin_angle, sin_angle, cos_angle, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> multiple_mode:</span><br><span class="line">                    <span class="comment"># 多行水印</span></span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_lines):</span><br><span class="line">                        y_pos = (i - num_lines/<span class="number">2</span>) * line_spacing * fontsize</span><br><span class="line">                        base_x = -text_width/<span class="number">2</span> + x_offset</span><br><span class="line">                        base_y = y_pos + y_offset</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment"># 计算插入点</span></span><br><span class="line">                        insert_point = fitz.Point(center_x + base_x, center_y + base_y)</span><br><span class="line">                        </span><br><span class="line">                        shape.insert_text(</span><br><span class="line">                            insert_point,</span><br><span class="line">                            wm_text,</span><br><span class="line">                            fontname=fontname,</span><br><span class="line">                            fontsize=fontsize,</span><br><span class="line">                            color=(r, g, b, opacity),  <span class="comment"># 在颜色中添加 alpha 通道</span></span><br><span class="line">                            morph=(center_point, rotation_matrix)</span><br><span class="line">                        )</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 单行水印</span></span><br><span class="line">                    base_x = -text_width/<span class="number">2</span> + x_offset</span><br><span class="line">                    base_y = y_offset</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 计算插入点</span></span><br><span class="line">                    insert_point = fitz.Point(center_x + base_x, center_y + base_y)</span><br><span class="line">                    </span><br><span class="line">                    shape.insert_text(</span><br><span class="line">                        insert_point,</span><br><span class="line">                        wm_text,</span><br><span class="line">                        fontname=fontname,</span><br><span class="line">                        fontsize=fontsize,</span><br><span class="line">                        color=(r, g, b, opacity),  <span class="comment"># 在颜色中添加 alpha 通道</span></span><br><span class="line">                        morph=(center_point, rotation_matrix)</span><br><span class="line">                    )</span><br><span class="line"></span><br><span class="line">                shape.commit()</span><br><span class="line">                wm_docs[size] = wm_doc</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 应用水印</span></span><br><span class="line">            overlay = <span class="literal">True</span> <span class="keyword">if</span> layer.lower() == <span class="string">"top"</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">            page.show_pdf_page(page.rect, wm_docs[size], <span class="number">0</span>, overlay=overlay)</span><br><span class="line">            page.clean_contents()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存修改后的 PDF</span></span><br><span class="line">        <span class="keyword">if</span> output_path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            p = Path(doc_path)</span><br><span class="line">            output_path = <span class="built_in">str</span>(p.parent / <span class="string">f"<span class="subst">{p.stem}</span>-加水印.pdf"</span>)</span><br><span class="line"></span><br><span class="line">        doc.save(output_path, garbage=<span class="number">4</span>, deflate=<span class="literal">True</span>, clean=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭所有文档</span></span><br><span class="line">        <span class="keyword">for</span> wm_doc <span class="keyword">in</span> wm_docs.values():</span><br><span class="line">            wm_doc.close()</span><br><span class="line">        doc.close()</span><br><span class="line"></span><br><span class="line">        utils.dump_json(cmd_output_path, {<span class="string">"status"</span>: <span class="string">"success"</span>, <span class="string">"message"</span>: <span class="string">""</span>})</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(traceback.format_exc())</span><br><span class="line">        utils.dump_json(cmd_output_path, {<span class="string">"status"</span>: <span class="string">"error"</span>, <span class="string">"message"</span>: <span class="built_in">str</span>(e)})</span><br></pre></td></tr></tbody></table></figure><p><strong>第一段代码（图片水印）</strong>：</p><ul><li>使用 ReportLab 创建了一个独立的 PDF 文件，其中包含图片水印。</li><li>通过 show_pdf_page，将这个水印 PDF 的内容流（包括图片的绘制指令和资源定义）追加到原始 PDF 的页面内容流中。</li><li><strong>结果</strong>：水印以图像 XObject 的形式嵌入，涉及资源管理和内容流的双重结构。</li></ul><p><strong>第二段代码（文本水印）</strong>：</p><ul><li>直接在原始 PDF 的页面上使用 Shape 对象绘制文本。</li><li>通过 commit 方法，将文本绘制指令直接写入页面内容流。</li><li><strong>结果</strong>：水印仅以文本指令的形式存在于内容流中，没有额外的资源依赖。</li></ul><p>尽管两段代码都最终修改了页面内容流，但第一段代码引入了图片资源（XObject），而第二段代码仅操作文本指令。这就是问题的核心所在。</p><p>最终可以增添文本水印背景的代码（不容易被轻易删除）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">watermark_pdf_by_text</span>(<span class="params"></span></span><br><span class="line"><span class="params">    doc_path: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    wm_text: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    page_range: <span class="built_in">str</span> = <span class="string">"all"</span>,</span></span><br><span class="line"><span class="params">    layer: <span class="built_in">str</span> = <span class="string">"top"</span>,</span></span><br><span class="line"><span class="params">    output_path: <span class="built_in">str</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    font: <span class="built_in">str</span> = <span class="string">"msyh.ttc"</span>,</span></span><br><span class="line"><span class="params">    fontsize: <span class="built_in">float</span> = <span class="number">30</span>,</span></span><br><span class="line"><span class="params">    angle: <span class="built_in">float</span> = <span class="number">45</span>,</span></span><br><span class="line"><span class="params">    text_stroke_color_rgb: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>] = (<span class="params"><span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span></span>),  <span class="comment"># 灰色描边</span></span></span><br><span class="line"><span class="params">    text_fill_color_rgb: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>] = (<span class="params"><span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span></span>),    <span class="comment"># 灰色填充</span></span></span><br><span class="line"><span class="params">    opacity: <span class="built_in">float</span> = <span class="number">1</span>,</span></span><br><span class="line"><span class="params">    num_lines: <span class="built_in">int</span> = <span class="number">1</span>,</span></span><br><span class="line"><span class="params">    line_spacing: <span class="built_in">float</span> = <span class="number">2</span>,</span></span><br><span class="line"><span class="params">    word_spacing: <span class="built_in">float</span> = <span class="number">2</span>,</span></span><br><span class="line"><span class="params">    multiple_mode: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    x_offset: <span class="built_in">float</span> = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">    y_offset: <span class="built_in">float</span> = <span class="number">0</span></span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 打开原始 PDF</span></span><br><span class="line">        doc = fitz.<span class="built_in">open</span>(doc_path)</span><br><span class="line">        roi_indices = utils.parse_range(page_range, doc.page_count)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 存储不同页面尺寸的水印图像</span></span><br><span class="line">        wm_images = {}</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理每页的水印</span></span><br><span class="line">        <span class="keyword">for</span> page_index <span class="keyword">in</span> roi_indices:</span><br><span class="line">            page = doc[page_index]</span><br><span class="line">            size = (page.rect.width, page.rect.height)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果该尺寸的水印尚未创建，则创建新的水印文档</span></span><br><span class="line">            <span class="keyword">if</span> size <span class="keyword">not</span> <span class="keyword">in</span> wm_images:</span><br><span class="line">                wm_doc = fitz.<span class="built_in">open</span>()  <span class="comment"># 在内存中创建新 PDF</span></span><br><span class="line">                wm_page = wm_doc.new_page(width=size[<span class="number">0</span>], height=size[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 加载字体</span></span><br><span class="line">                fontname = utils.load_font(wm_doc, font)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 创建 Shape 对象</span></span><br><span class="line">                shape = wm_page.new_shape()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 设置填充颜色（RGB 转换为浮点数）</span></span><br><span class="line">                r, g, b = [x/<span class="number">255.0</span> <span class="keyword">for</span> x <span class="keyword">in</span> text_fill_color_rgb]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 计算文本宽度</span></span><br><span class="line">                text_width = fitz.get_text_length(wm_text, fontname=fontname, fontsize=fontsize)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 计算中心点</span></span><br><span class="line">                center_x = size[<span class="number">0</span>] / <span class="number">2</span></span><br><span class="line">                center_y = size[<span class="number">1</span>] / <span class="number">2</span></span><br><span class="line">                center_point = fitz.Point(center_x, center_y)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 创建旋转矩阵（仅旋转，不包含平移）</span></span><br><span class="line">                angle_rad = math.radians(angle)  <span class="comment"># 转换为弧度</span></span><br><span class="line">                cos_angle = math.cos(angle_rad)</span><br><span class="line">                sin_angle = math.sin(angle_rad)</span><br><span class="line">                rotation_matrix = fitz.Matrix(cos_angle, -sin_angle, sin_angle, cos_angle, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> multiple_mode:</span><br><span class="line">                    <span class="comment"># 多行水印</span></span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_lines):</span><br><span class="line">                        y_pos = (i - num_lines/<span class="number">2</span>) * line_spacing * fontsize</span><br><span class="line">                        base_x = -text_width/<span class="number">2</span> + x_offset</span><br><span class="line">                        base_y = y_pos + y_offset</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment"># 计算插入点</span></span><br><span class="line">                        insert_point = fitz.Point(center_x + base_x, center_y + base_y)</span><br><span class="line">                        </span><br><span class="line">                        shape.insert_text(</span><br><span class="line">                            insert_point,</span><br><span class="line">                            wm_text,</span><br><span class="line">                            fontname=fontname,</span><br><span class="line">                            fontsize=fontsize,</span><br><span class="line">                            color=(r, g, b, opacity),  <span class="comment"># 在颜色中添加 alpha 通道</span></span><br><span class="line">                            morph=(center_point, rotation_matrix)</span><br><span class="line">                        )</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 单行水印</span></span><br><span class="line">                    base_x = -text_width/<span class="number">2</span> + x_offset</span><br><span class="line">                    base_y = y_offset</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 计算插入点</span></span><br><span class="line">                    insert_point = fitz.Point(center_x + base_x, center_y + base_y)</span><br><span class="line">                    </span><br><span class="line">                    shape.insert_text(</span><br><span class="line">                        insert_point,</span><br><span class="line">                        wm_text,</span><br><span class="line">                        fontname=fontname,</span><br><span class="line">                        fontsize=fontsize,</span><br><span class="line">                        color=(r, g, b, opacity),  <span class="comment"># 在颜色中添加 alpha 通道</span></span><br><span class="line">                        morph=(center_point, rotation_matrix)</span><br><span class="line">                    )</span><br><span class="line"></span><br><span class="line">                shape.commit()</span><br><span class="line">                pix = wm_page.get_pixmap(alpha=<span class="literal">True</span>)</span><br><span class="line">                wm_images[size] = pix</span><br><span class="line">                wm_doc.close()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 应用水印图片</span></span><br><span class="line">            overlay = <span class="literal">True</span> <span class="keyword">if</span> layer.lower() == <span class="string">"top"</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">            wm_pix = wm_images[size]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 使用缓存区创建水印 PDF</span></span><br><span class="line">            buf = BytesIO()</span><br><span class="line">            temp_pdf = fitz.<span class="built_in">open</span>()</span><br><span class="line">            temp_page = temp_pdf.new_page(width=wm_pix.width, height=wm_pix.height)</span><br><span class="line">            temp_page.insert_image(fitz.Rect(<span class="number">0</span>, <span class="number">0</span>, wm_pix.width, wm_pix.height), pixmap=wm_pix)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 保存到内存中的缓存区</span></span><br><span class="line">            temp_pdf.save(buf)</span><br><span class="line">            buf.seek(<span class="number">0</span>)  <span class="comment"># 将缓存区指针重新定位到文件的开头</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将缓存区中的 PDF 通过 show_pdf_page 插入到原始页面</span></span><br><span class="line">            buf_pdf = fitz.<span class="built_in">open</span>(<span class="string">"pdf"</span>, buf.read())</span><br><span class="line">            wm_rect = page.rect</span><br><span class="line">            page.show_pdf_page(wm_rect, buf_pdf, <span class="number">0</span>, overlay=overlay)</span><br><span class="line">            page.clean_contents()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存修改后的 PDF</span></span><br><span class="line">        <span class="keyword">if</span> output_path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            p = Path(doc_path)</span><br><span class="line">            output_path = <span class="built_in">str</span>(p.parent / <span class="string">f"<span class="subst">{p.stem}</span>-加水印.pdf"</span>)</span><br><span class="line"></span><br><span class="line">        doc.save(output_path, garbage=<span class="number">4</span>, deflate=<span class="literal">True</span>, clean=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭所有文档</span></span><br><span class="line">        buf_pdf.close()</span><br><span class="line">        doc.close()</span><br><span class="line"></span><br><span class="line">        utils.dump_json(cmd_output_path, {<span class="string">"status"</span>: <span class="string">"success"</span>, <span class="string">"message"</span>: <span class="string">""</span>})</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(traceback.format_exc())</span><br><span class="line">        utils.dump_json(cmd_output_path, {<span class="string">"status"</span>: <span class="string">"error"</span>, <span class="string">"message"</span>: <span class="built_in">str</span>(e)})</span><br></pre></td></tr></tbody></table></figure><h2 id="PDF-XPS-EPUB-MOBI-FB2-CBZ"><a href="#PDF-XPS-EPUB-MOBI-FB2-CBZ" class="headerlink" title="PDF, XPS, EPUB, MOBI, FB2, CBZ,"></a>PDF, XPS, EPUB, MOBI, FB2, CBZ,</h2><ul><li><strong>PDF（便携式文档格式，Portable Document Format）</strong><br> 这是一种由 Adobe Systems 开发的文件格式，用于在不同平台上呈现和交换文档。PDF 文件的特点是能够保持文字、图像和排版的完整性，无论在何种设备或操作系统上查看，显示效果都一致。</li><li><strong>XPS（XML纸张规范，XML Paper Specification）</strong><br> 由 Microsoft 开发的文件格式，类似于 PDF，但基于 XML 技术。XPS 旨在提供一种跨平台的文档查看方式，通常用于保存和共享固定布局的文档。</li><li><strong>EPUB（电子出版物，Electronic Publication）</strong><br> 这是一种开放标准的电子书格式，广泛用于数字出版物。EPUB 文件支持动态调整布局，适合在不同尺寸的屏幕上阅读，常用于电子书出版。</li><li><strong>MOBI（Mobipocket电子书）</strong><br> 最初由 Mobipocket SA 开发的一种电子书格式，后来被 Amazon 收购并用于 Kindle 设备和应用程序。MOBI 文件主要用于存储电子书内容，支持基本的格式和导航功能。</li><li><strong>FB2（FictionBook 2）</strong><br> 这是一种专为小说和文学作品设计的电子书格式，基于 XML，支持结构化的内容（如章节、标题）和丰富的元数据（如作者、书名）。它在俄罗斯等地区较为流行。</li><li><strong>CBZ（漫画书存档，Comic Book Archive）</strong><br> 一种将漫画书页面图像打包成单个文件的格式，通常使用 ZIP 压缩。CBZ 文件便于存储和分发数字化漫画，常与漫画阅读软件一起使用。</li><li><strong>SVG（可缩放矢量图形，Scalable Vector Graphics）</strong><br> 一种基于 XML 的矢量图像格式，主要用于 Web 和图形设计。SVG 文件可以无损缩放，适合显示高质量的图标、图表和插图。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这些文件格式各有侧重：</p><ul><li><p><strong>文档类</strong>：PDF 和 XPS 适用于固定布局的文档共享。</p></li><li><p><strong>电子书类</strong>：EPUB、MOBI 和 FB2 专注于电子书阅读体验。</p></li><li><p><strong>漫画类</strong>：CBZ 专为漫画存储设计。</p></li><li><p><strong>图像类</strong>：SVG 用于矢量图形展示。</p></li></ul><h2 id="fitz-LINK-NAMED-类型的链接，这是PDF文档中的一种特殊链接类型。"><a href="#fitz-LINK-NAMED-类型的链接，这是PDF文档中的一种特殊链接类型。" class="headerlink" title="fitz.LINK_NAMED 类型的链接，这是PDF文档中的一种特殊链接类型。"></a>fitz.LINK_NAMED 类型的链接，这是PDF文档中的一种特殊链接类型。</h2><p>LINK_NAMED 链接（命名链接）具有以下特点：</p><p>这类链接指向文档中的命名目标（named destinations），而不是直接指向页码或URL</p><p>命名目标是PDF中的一种特殊标记，通过名称而非页码来引用文档中的特定位置</p><p>这种链接通常用于PDF的高级导航功能，如书签跳转到特定命名位置</p><p>代码跳过这些链接的可能原因：</p><p>命名链接在转换过程中可能无法正确映射到新文档结构</p><p>目标文档格式可能不支持命名目标的概念</p><p>处理这类链接需要额外的逻辑来解析和映射命名目标</p><p>当发现命名链接时，代码会：</p><p>记录日志（logger.info(“name link page”, pinnut.number, l)）</p><p>增加跳过计数（link_skip += 1）</p><p>不将此链接添加到新文档中</p><p>这种处理方式确保了转换过程不会因为无法处理的命名链接而出错，但同时也意味着最终文档中会缺少这些特定类型的链接功能。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">link_cnti = <span class="number">0</span></span><br><span class="line">link_skip = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> pinnut <span class="keyword">in</span> doc:</span><br><span class="line">    links = pinnut.get_links()</span><br><span class="line">    link_cnti += <span class="built_in">len</span>(links)</span><br><span class="line">    pout = pdf[pinnut.number]</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> links:</span><br><span class="line">        <span class="keyword">if</span> l[<span class="string">"kind"</span>] == fitz.LINK_NAMED:</span><br><span class="line">            logger.info(<span class="string">"name link page"</span>,pinnut.number,l)</span><br><span class="line">            link_skip += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        pout.insert_link(l)</span><br></pre></td></tr></tbody></table></figure><h2 id="PDF2DOCX"><a href="#PDF2DOCX" class="headerlink" title="PDF2DOCX"></a>PDF2DOCX</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert_pdf_docx</span>(<span class="params">doc_path: <span class="built_in">str</span>, output_path: <span class="built_in">str</span> = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">"""将PDF转换为DOCX</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        doc_path: 输入PDF路径</span></span><br><span class="line"><span class="string">        output_path: 输出DOCX路径，默认为None时自动生成</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> output_path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            p = Path(doc_path)</span><br><span class="line">            output_path = <span class="built_in">str</span>(p.parent / <span class="string">f"<span class="subst">{p.stem}</span>.docx"</span>)</span><br><span class="line">            </span><br><span class="line">        cv = Converter(doc_path)</span><br><span class="line">        cv.convert(output_path, start=<span class="number">0</span>, end=<span class="literal">None</span>)</span><br><span class="line">        cv.close()</span><br><span class="line">        </span><br><span class="line">        logger.info(<span class="string">f"成功转换: <span class="subst">{doc_path}</span> -&gt; <span class="subst">{output_path}</span>"</span>)</span><br><span class="line">        utils.dump_json(cmd_output_path, {<span class="string">"status"</span>: <span class="string">"success"</span>, <span class="string">"message"</span>: <span class="string">"转换完成"</span>})</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        error_msg = traceback.format_exc()</span><br><span class="line">        logger.error(<span class="string">f"转换失败: <span class="subst">{error_msg}</span>"</span>)</span><br><span class="line">        utils.dump_json(cmd_output_path, {<span class="string">"status"</span>: <span class="string">"error"</span>, <span class="string">"message"</span>: <span class="built_in">str</span>(e)})</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pymupdf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件处理2.24</title>
      <link href="/2025/02/24/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-2-24/"/>
      <url>/2025/02/24/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-2-24/</url>
      
        <content type="html"><![CDATA[<h2 id="shape-insert-text-函数的用法"><a href="#shape-insert-text-函数的用法" class="headerlink" title="shape.insert_text 函数的用法"></a><strong>shape.insert_text 函数的用法</strong></h2><p>morph 参数用于在插入文本后应用变换（如旋转、平移等）。它的格式必须是：</p><ul><li><strong>一个长度为 2 的序列</strong>，例如 (fixpoint, matrix)。</li><li>其中：<ul><li>fixpoint 是一个 fitz.Point 对象，表示变换的固定点（例如旋转的中心点）。</li><li>matrix 是一个 fitz.Matrix 对象，表示要应用的变换矩阵。</li></ul></li></ul><p>当前代码直接将 matrix 赋值给 morph，导致类型不符合要求，因此抛出了 ValueError</p><h4 id="正确使用-morph-参数"><a href="#正确使用-morph-参数" class="headerlink" title="正确使用 morph 参数"></a>正确使用 morph 参数</h4><p>按照 PyMuPDF 文档的要求，我们可以将 morph 设置为一个长度为 2 的元组 (fixpoint, matrix)。具体步骤如下：</p><ol><li><strong>定义固定点</strong>：固定点是变换（例如旋转）的中心，通常是页面中心 (center_x, center_y)。</li><li><strong>定义变换矩阵</strong>：仅包含旋转部分，不包含平移（因为平移可以通过插入点或固定点控制）。</li><li><strong>调整插入点</strong>：将文本插入到适当位置，然后通过 morph 应用旋转。</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算中心点</span></span><br><span class="line">center_x = size[<span class="number">0</span>] / <span class="number">2</span></span><br><span class="line">center_y = size[<span class="number">1</span>] / <span class="number">2</span></span><br><span class="line">center_point = fitz.Point(center_x, center_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建旋转矩阵（仅旋转，不包含平移）</span></span><br><span class="line">angle_rad = math.radians(angle)  <span class="comment"># 转换为弧度</span></span><br><span class="line">cos_angle = math.cos(angle_rad)</span><br><span class="line">sin_angle = math.sin(angle_rad)</span><br><span class="line">rotation_matrix = fitz.Matrix(cos_angle, -sin_angle, sin_angle, cos_angle, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单行水印</span></span><br><span class="line">    base_x = -text_width / <span class="number">2</span> + x_offset</span><br><span class="line">    base_y = y_offset</span><br><span class="line">    insert_point = fitz.Point(center_x + base_x, center_y + base_y)</span><br><span class="line">    shape.insert_text(</span><br><span class="line">        insert_point,  <span class="comment"># 插入点</span></span><br><span class="line">        wm_text,</span><br><span class="line">        fontname=fontname,</span><br><span class="line">        fontsize=fontsize,</span><br><span class="line">        color=(r, g, b, opacity),</span><br><span class="line">        morph=(center_point, rotation_matrix)  <span class="comment"># 固定点和旋转矩阵</span></span><br><span class="line">    )</span><br></pre></td></tr></tbody></table></figure><p>insert_point 是文本的插入位置，相对于页面坐标系计算。</p><p>morph=(center_point, rotation_matrix) 表示在插入文本后，围绕页面中心 center_point 应用旋转矩阵 rotation_matrix。</p><p>平移（x_offset, y_offset）直接在插入点中处理，不需要包含在矩阵中。</p><p>shape.insert_text 是 PyMuPDF（fitz 库）中 Shape 类的一个方法，用于在 PDF 页面上插入文本。它提供了多种参数，可以控制文本的位置、字体、大小、颜色等属性。以下是它的基本用法和参数说明：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shape.insert_text(</span><br><span class="line">    point, </span><br><span class="line">    text, </span><br><span class="line">    fontname=<span class="string">"helv"</span>, </span><br><span class="line">    fontsize=<span class="number">11</span>, </span><br><span class="line">    color=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), </span><br><span class="line">    opacity=<span class="number">1.0</span>, </span><br><span class="line">    morph=<span class="literal">None</span>, </span><br><span class="line">    rotate=<span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><h5 id="关键参数说明"><a href="#关键参数说明" class="headerlink" title="关键参数说明"></a><strong>关键参数说明</strong></h5><ul><li><strong>point</strong>：一个 fitz.Point 对象，指定文本插入的起始位置（左下角坐标）。</li><li><strong>text</strong>：要插入的文本内容（字符串）。</li><li><strong>fontname</strong>：字体名称，默认是 “helv”（Helvetica），可以用内置字体或自定义字体。</li><li><strong>fontsize</strong>：字体大小，默认是 11。</li><li><strong>color</strong>：文本颜色，可以是 RGB 元组 (r, g, b)（取值 0-1）或 RGBA 元组 (r, g, b, a)，其中 a 是透明度（0.0 表示完全透明，1.0 表示完全不透明）。</li><li><strong>opacity</strong>：文本的透明度（0.0 到 1.0），默认是 1.0（不透明）。</li><li><strong>morph</strong>：可选参数，用于对文本进行形态变换（如旋转、缩放）。</li><li><strong>rotate</strong>：文本旋转角度（支持 0、90、180、270 度）。</li></ul><p>这个方法非常灵活，适合在 PDF 上添加水印、注释等内容。</p><h2 id="‘Document’-object-has-no-attribute-‘insert-font’"><a href="#‘Document’-object-has-no-attribute-‘insert-font’" class="headerlink" title="‘Document’ object has no attribute ‘insert_font’"></a>‘Document’ object has no attribute ‘insert_font’</h2><p>这表明 doc 对象（即 fitz.Document 实例）没有 insert_font 方法，导致代码无法正常运行。下面我将详细解释 doc.insert_font 方法的作用以及报错的原因，并提供解决方案。</p><p>doc.insert_font 是 PyMuPDF（fitz 库）中用于在 PDF 文档中插入字体的方法。它的主要功能包括：</p><p><strong>加载外部字体</strong>：从字体文件（如 .ttf、.ttc 等）的二进制数据（fontbuffer）中读取字体信息。</p><p><strong>注册字体到 PDF</strong>：将加载的字体嵌入 PDF 文档中，并返回一个字体名称（fontname），供后续文本操作（如插入文本或绘制文本）使用。</p><p>在支持</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fontname = doc.insert_font(fontbuffer=font_data, fontname="custom")</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>fontbuffer</strong>：字体文件的二进制数据，通常通过读取字体文件（如 msyh.ttc）获得。</li><li><strong>fontname</strong>：用户定义的字体名称，用于在 PDF 中引用该字体。</li></ul><p>例如，在您的代码中：</p><p>python此方法的 PyMuPDF 版本中，典型用法如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fontname = doc.insert_font(fontbuffer=font_data, fontname="custom")</span><br></pre></td></tr></tbody></table></figure><p><strong>fontbuffer</strong>：字体文件的二进制数据，通常通过读取字体文件（如 msyh.ttc）获得。</p><p><strong>fontname</strong>：用户定义的字体名称，用于在 PDF 中引用该字体</p><p><strong>doc.insert_font 的作用</strong>：在 PDF 文档中插入外部字体并注册，返回字体名称供后续使用。</p><p><strong>报错原因</strong>：可能是 PyMuPDF 版本不兼容（insert_font 被移除或变更）、对象类型错误或方法名错误。</p><p><strong>解决方法</strong>：升级 PyMuPDF 并检查 API，或使用 fitz.Font 类替代 doc.insert_font，如上改进代码所示。</p><h3 id="fitz-Font的用法"><a href="#fitz-Font的用法" class="headerlink" title="fitz.Font的用法"></a><strong>fitz.Font的用法</strong></h3><p>fitz.Font是PyMuPDF（也称为fitz）库中的一个类，用于在PDF文档中管理字体。它允许用户加载外部字体文件（如.ttf、.ttc等）或使用PyMuPDF内置的字体，以便在PDF中插入文本时使用。以下是关于fitz.Font的详细用法说明。</p><h4 id="fitz-Font的作用"><a href="#fitz-Font的作用" class="headerlink" title="fitz.Font的作用"></a><strong>fitz.Font的作用</strong></h4><ul><li><strong>加载外部字体</strong>：从字体文件中加载自定义字体，以便在PDF中显示特定样式的文本。</li><li><strong>使用内置字体</strong>：PyMuPDF提供了一些内置字体，如helv（Helvetica）、china-s（中文字体）等，方便在没有外部字体时使用。</li><li><strong>字体管理</strong>：通过fitz.Font对象，用户可以获取字体的名称、属性，并将其应用于PDF中的文本操作。</li></ul><p><strong>2.1 加载外部字体</strong></p><p>要加载外部字体文件，可以使用fitz.Font构造函数，并传入字体文件的路径或其他参数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fitz  <span class="comment"># PyMuPDF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开PDF文档</span></span><br><span class="line">doc = fitz.<span class="built_in">open</span>(<span class="string">"example.pdf"</span>)</span><br><span class="line">page = doc[<span class="number">0</span>]  <span class="comment"># 选择第一页</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载外部字体（例如微软雅黑）</span></span><br><span class="line">font_path = <span class="string">"C:/Windows/Fonts/msyh.ttc"</span>  <span class="comment"># 字体文件路径</span></span><br><span class="line">font = fitz.Font(fontfile=font_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取字体名称</span></span><br><span class="line">fontname = font.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在页面上插入文本</span></span><br><span class="line">page.insert_text(</span><br><span class="line">    (<span class="number">100</span>, <span class="number">100</span>),  <span class="comment"># 插入位置</span></span><br><span class="line">    <span class="string">"测试文本"</span>,  <span class="comment"># 文本内容</span></span><br><span class="line">    fontname=fontname,  <span class="comment"># 使用加载的字体</span></span><br><span class="line">    fontsize=<span class="number">12</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存PDF</span></span><br><span class="line">doc.save(<span class="string">"output.pdf"</span>)</span><br><span class="line">doc.close()</span><br></pre></td></tr></tbody></table></figure><p><strong>解释</strong>：</p><ul><li>fitz.Font(fontfile=font_path)：加载指定路径的字体文件。</li><li>font.name：获取字体的名称，供insert_text等方法使用。</li><li>page.insert_text：在PDF页面上插入文本，并指定使用加载的字体。</li></ul><p><strong>2.2 使用内置字体</strong></p><p>PyMuPDF内置了一些常用的字体，可以直接通过字体名称使用。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fitz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开PDF文档</span></span><br><span class="line">doc = fitz.<span class="built_in">open</span>(<span class="string">"example.pdf"</span>)</span><br><span class="line">page = doc[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用内置字体 Helvetica</span></span><br><span class="line">font = fitz.Font(<span class="string">"helv"</span>)  <span class="comment"># 内置Helvetica字体</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在页面上插入文本</span></span><br><span class="line">page.insert_text(</span><br><span class="line">    (<span class="number">100</span>, <span class="number">100</span>),</span><br><span class="line">    <span class="string">"Hello, World!"</span>,</span><br><span class="line">    fontname=font.name,</span><br><span class="line">    fontsize=<span class="number">12</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存PDF</span></span><br><span class="line">doc.save(<span class="string">"output.pdf"</span>)</span><br><span class="line">doc.close()</span><br></pre></td></tr></tbody></table></figure><p><strong>解释</strong>：</p><ul><li><p>fitz.Font(“helv”)：加载内置的Helvetica字体。</p></li><li><p>font.name：获取内置字体的名称。</p></li></ul><h4 id="2-3-fitz-Font构造函数的参数"><a href="#2-3-fitz-Font构造函数的参数" class="headerlink" title="2.3 fitz.Font构造函数的参数"></a><strong>2.3 fitz.Font构造函数的参数</strong></h4><p>fitz.Font构造函数支持以下参数：</p><ul><li><strong>fontfile</strong>（可选）：外部字体文件的路径（str），用于加载自定义字体。</li><li><strong>fontname</strong>（可选）：内置字体的名称（如”helv”、”china-s”等），用于加载PyMuPDF内置字体。</li><li><strong>fontbuffer</strong>（可选）：字体文件的二进制数据（bytes），替代fontfile参数。</li><li><strong>weight</strong>（可选）：字体的粗细（int），默认为400（正常）。</li></ul><p><strong>注意</strong>：</p><ul><li><p>fontfile和fontname不能同时使用。</p></li><li><p>如果同时提供fontfile和fontname，fontfile将优先使用。</p></li></ul><h4 id="2-4-fitz-Font对象的属性和方法"><a href="#2-4-fitz-Font对象的属性和方法" class="headerlink" title="2.4 fitz.Font对象的属性和方法"></a><strong>2.4 fitz.Font对象的属性和方法</strong></h4><ul><li><strong>name</strong>：字体的名称（str），用于在PDF中引用该字体。</li><li><strong>buffer</strong>：字体的二进制数据（bytes）。</li><li><strong>is_bold</strong>：字体是否为粗体（bool）。</li><li><strong>is_italic</strong>：字体是否为斜体（bool）。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">font = fitz.Font(fontfile=<span class="string">"path/to/font.ttf"</span>)</span><br><span class="line"><span class="built_in">print</span>(font.name)  <span class="comment"># 输出字体名称</span></span><br><span class="line"><span class="built_in">print</span>(font.is_bold)  <span class="comment"># 检查是否为粗体</span></span><br></pre></td></tr></tbody></table></figure><p>show_pdf_page()</p><p><strong>show_pdf_page 方法的用法</strong></p><p>show_pdf_page 是 PyMuPDF（fitz 库）中 Page 类的一个方法，用于将一个 PDF 页面（源页面）的全部或部分内容显示到另一个 PDF 页面（目标页面）上。它常用于添加水印、页眉、页脚等内容。</p><p>基本语法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">page.show_pdf_page(</span><br><span class="line">    rect, </span><br><span class="line">    src, </span><br><span class="line">    pno, </span><br><span class="line">    clip=<span class="literal">None</span>, </span><br><span class="line">    rotate=<span class="number">0</span>, </span><br><span class="line">    overlay=<span class="literal">True</span>, </span><br><span class="line">    oc=<span class="number">0</span>, </span><br><span class="line">    keep_proportion=<span class="literal">True</span>, </span><br><span class="line">    invert_alpha=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>参数说明</p><p>以下是 show_pdf_page 方法支持的主要参数及其含义：</p><p><strong>rect</strong>（必填）：<br> 类型：fitz.Rect 对象<br> 描述：目标页面上用于显示源页面内容的矩形区域，指定位置和大小。</p><p><strong>src</strong>（必填）：<br> 类型：fitz.Document 对象<br> 描述：源 PDF 文档，从中提取要显示的页面内容。</p><p><strong>pno</strong>（必填）：<br> 类型：整数<br> 描述：源 PDF 文档中的页码，从 0 开始计数。</p><p><strong>clip</strong>（可选）：<br> 类型：fitz.Rect 对象，默认值：None<br> 描述：源页面中的裁剪矩形，仅显示裁剪区域内的内容。</p><p><strong>rotate</strong>（可选）：<br> 类型：整数，默认值：0<br> 描述：源页面内容的旋转角度，可选值为 0、90、180、270（单位：度）。</p><p><strong>overlay</strong>（可选）：<br> 类型：布尔值，默认值：True<br> 描述：控制源页面内容与目标页面内容的叠放顺序。</p><ul><li>True：源页面内容叠加在目标页面内容之上（前景）。</li><li>False：源页面内容叠加在目标页面内容之下（背景）。</li></ul><p><strong>oc</strong>（可选）：<br> 类型：整数，默认值：0<br> 描述：可选内容组（Optional Content Group）的 ID，用于控制内容的可见性。</p><p><strong>keep_proportion</strong>（可选）：<br> 类型：布尔值，默认值：True<br> 描述：是否保持源页面内容的宽高比。</p><ul><li>True：按比例缩放以适应目标矩形。</li><li>False：可能导致内容拉伸或变形。</li></ul><p><strong>invert_alpha</strong>（可选）：<br> 类型：布尔值，默认值：False<br> 描述：是否反转透明度通道（alpha channel），用于处理透明效果。</p>]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pymupdf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件处理项目2.23</title>
      <link href="/2025/02/23/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-2-23/"/>
      <url>/2025/02/23/wen-jian-chu-li-xiang-mu/wen-jian-chu-li-2-23/</url>
      
        <content type="html"><![CDATA[<h1 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h1><p><strong>canvas.Canvas</strong>是来自 <code>reportlab</code> 库的一种对象，通常用于生成 PDF 文件。它提供了多种方法来绘制文本、图形、图片等内容。代码中的 <code>canvas.Canvas(wm_output_path, pagesize=(width, height))</code> 表示创建一个新的 PDF 画布并指定输出路径和页面尺寸。</p><h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><ol><li>**<code>wm_output_path</code>**：PDF 文件的输出路径，指定生成的 PDF 文件存储的位置和文件名。</li><li>**<code>pagesize=(width, height)</code>**：指定页面的大小。<code>width</code> 和 <code>height</code> 是页面的宽度和高度。<code>pagesize</code> 可以是元组 <code>(宽度, 高度)</code>，例如 <code>(595, 842)</code> 表示 A4 纸的大小，单位是点（1 点 = 1/72 英寸）。</li></ol><h3 id="常见的-Canvas-方法："><a href="#常见的-Canvas-方法：" class="headerlink" title="常见的 Canvas 方法："></a>常见的 <code>Canvas</code> 方法：</h3><ul><li><p>**<code>drawString(x, y, text)</code>**：在指定位置 <code>(x, y)</code> 绘制文本 <code>text</code>。</p></li><li><p>**<code>line(x1, y1, x2, y2)</code>**：在指定的两个坐标 <code>(x1, y1)</code> 和 <code>(x2, y2)</code> 之间绘制一条线。</p></li><li><p>**<code>rect(x, y, width, height)</code>**：绘制一个矩形，左下角在 <code>(x, y)</code> 位置，宽度为 <code>width</code>，高度为 <code>height</code>。</p></li><li><p>**<code>setFont(fontname, fontsize)</code>**：设置文本的字体和大小。</p></li><li><p>**<code>save()</code>**：保存并关闭 PDF 文件。</p><h3 id="canvas-Canvas-参数"><a href="#canvas-Canvas-参数" class="headerlink" title="canvas.Canvas 参数"></a><code>canvas.Canvas</code> 参数</h3><h3 id="1-filename（必需）"><a href="#1-filename（必需）" class="headerlink" title="1. filename（必需）"></a>1. <strong><code>filename</code>（必需）</strong></h3><ul><li><strong>描述</strong>：输出的 PDF 文件路径。</li><li><strong>类型</strong>：字符串</li><li><strong>示例</strong>：<code>"output.pdf"</code></li></ul><h3 id="2-pagesize（可选）"><a href="#2-pagesize（可选）" class="headerlink" title="2. pagesize（可选）"></a>2. <code>pagesize</code>（可选）</h3><ul><li><strong>描述</strong>：指定页面的大小。</li><li><strong>类型</strong>：元组 <code>(宽度, 高度)</code>，单位为点（1点 = 1/72英寸）。</li><li><strong>示例</strong>：<code>pagesize=(595, 842)</code>（A4纸大小）</li></ul><h3 id="3-pagecompression（可选）"><a href="#3-pagecompression（可选）" class="headerlink" title="3. pagecompression（可选）"></a>3. <code>pagecompression</code>（可选）</h3><ul><li><strong>描述</strong>：是否启用页面内容的压缩。默认是 <code>True</code>，启用压缩。</li><li><strong>类型</strong>：布尔值 (<code>True</code> 或 <code>False</code>)</li><li><strong>示例</strong>：<code>pagecompression=True</code></li></ul><h3 id="4-rotation（可选）"><a href="#4-rotation（可选）" class="headerlink" title="4. rotation（可选）"></a>4. <code>rotation</code>（可选）</h3><ul><li><strong>描述</strong>：设置默认的页面旋转角度（顺时针旋转）。</li><li><strong>类型</strong>：整数（单位：度）</li><li><strong>示例</strong>：<code>rotation=90</code></li></ul><h3 id="5-bottomup（可选）"><a href="#5-bottomup（可选）" class="headerlink" title="5. bottomup（可选）"></a>5. <code>bottomup</code>（可选）</h3><ul><li><strong>描述</strong>：如果设置为 <code>True</code>，页面的原点将在页面的底部而不是顶部。</li><li><strong>类型</strong>：布尔值 (<code>True</code> 或 <code>False</code>)</li><li><strong>示例</strong>：<code>bottomup=True</code></li></ul><h3 id="6-debug（可选）"><a href="#6-debug（可选）" class="headerlink" title="6. debug（可选）"></a>6. <code>debug</code>（可选）</h3><ul><li><strong>描述</strong>：是否启用调试模式，通常用于显示更多的错误信息。</li><li><strong>类型</strong>：布尔值 (<code>True</code> 或 <code>False</code>)</li><li><strong>示例</strong>：<code>debug=True</code></li></ul><h3 id="7-encrypt（可选）"><a href="#7-encrypt（可选）" class="headerlink" title="7. encrypt（可选）"></a>7. <code>encrypt</code>（可选）</h3><ul><li><strong>描述</strong>：是否对 PDF 文件进行加密。通常需要提供 <code>user_pw</code> 和 <code>owner_pw</code> 来设置密码。</li><li><strong>类型</strong>：布尔值 (<code>True</code> 或 <code>False</code>)</li><li><strong>示例</strong>：<code>encrypt=True</code></li></ul><h3 id="8-userpassword（可选）"><a href="#8-userpassword（可选）" class="headerlink" title="8. userpassword（可选）"></a>8. <code>userpassword</code>（可选）</h3><ul><li><strong>描述</strong>：设置用于加密文件的用户密码。</li><li><strong>类型</strong>：字符串</li><li><strong>示例</strong>：<code>userpassword="mypassword"</code></li></ul><h3 id="9-ownerpassword（可选）"><a href="#9-ownerpassword（可选）" class="headerlink" title="9. ownerpassword（可选）"></a>9. <code>ownerpassword</code>（可选）</h3><ul><li><strong>描述</strong>：设置用于加密文件的所有者密码。</li><li><strong>类型</strong>：字符串</li><li><strong>示例</strong>：<code>ownerpassword="ownerpassword"</code></li></ul><h3 id="10-allowPrinting（可选）"><a href="#10-allowPrinting（可选）" class="headerlink" title="10. allowPrinting（可选）"></a>10. <code>allowPrinting</code>（可选）</h3><ul><li><strong>描述</strong>：设置是否允许打印加密的 PDF 文件。默认为 <code>True</code>。</li><li><strong>类型</strong>：布尔值 (<code>True</code> 或 <code>False</code>)</li><li><strong>示例</strong>：<code>allowPrinting=True</code></li></ul><h3 id="11-allowCopying（可选）"><a href="#11-allowCopying（可选）" class="headerlink" title="11. allowCopying（可选）"></a>11. <code>allowCopying</code>（可选）</h3><ul><li><strong>描述</strong>：设置是否允许复制文件内容。默认为 <code>True</code>。</li><li><strong>类型</strong>：布尔值 (<code>True</code> 或 <code>False</code>)</li><li><strong>示例</strong>：<code>allowCopying=False</code></li></ul><h3 id="12-autoPageSize（可选）"><a href="#12-autoPageSize（可选）" class="headerlink" title="12. autoPageSize（可选）"></a>12. <code>autoPageSize</code>（可选）</h3><ul><li><strong>描述</strong>：是否自动调整页面大小。默认是 <code>True</code>，自动调整。</li><li><strong>类型</strong>：布尔值 (<code>True</code> 或 <code>False</code>)</li><li><strong>示例</strong>：<code>autoPageSize=False</code></li></ul></li></ul><h1 id="Pymupdf-show-pdf-page"><a href="#Pymupdf-show-pdf-page" class="headerlink" title="Pymupdf show_pdf_page"></a>Pymupdf show_pdf_page</h1><p><code>show_pdf_page</code> 是 PyMuPDF 库中的一个方法，用于在当前页面上显示另一个 PDF 页面的内容。这个方法可以将一个页面渲染到另一个页面的指定区域。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show_pdf_page(rect, doc, pageno, clip=None, overlay=False, rotation=0)</span><br></pre></td></tr></tbody></table></figure><h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><ol><li><strong>rect</strong> (<code>Rect</code> 对象):<br>这是目标页面中用来放置 PDF 页面内容的矩形区域。<code>rect</code> 定义了目标页面上的显示区域，通常可以通过获取当前页面的 <code>rect</code> 属性来设置。例如，<code>new_page.rect</code> 是一个矩形区域，表示新页面的大小。</li><li><strong>doc</strong> (<code>Document</code> 对象):<br>这是包含要显示页面内容的 PDF 文档对象。你通常会通过 <code>fitz.open("file.pdf")</code> 打开 PDF 文件，获取一个 <code>Document</code> 实例。</li><li><strong>pageno</strong> (<code>int</code>):<br>这是你要从 <code>doc</code> 中提取的页面的页码。页码是从 0 开始的整数，表示你要显示的页面在文档中的位置。例如，<code>pageno=0</code> 表示显示文档中的第一页。</li><li><strong>clip</strong> (<code>Rect</code> 对象, 可选):<br>这是一个可选的矩形区域，用来限制从源页面中提取内容的区域。如果未提供，默认情况下将显示整个页面内容。使用 <code>clip</code> 参数可以选择只显示源页面的一部分。</li><li><strong>overlay</strong> (<code>bool</code>, 可选):<br>这是一个布尔值，决定是否将目标页面内容覆盖现有内容。如果 <code>overlay=True</code>，那么显示的页面内容会直接覆盖在目标页面已有内容上。如果 <code>overlay=False</code>，则内容会被绘制在目标页面的指定区域，但不会覆盖现有的内容。默认值是 <code>False</code>。</li><li><strong>rotation</strong> (<code>int</code>, 可选):<br>这是一个整数，表示渲染时对源页面进行的旋转角度。旋转角度的单位是度（degree），可以为 0、90、180 或 270 度。默认值是 0，表示不进行旋转。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 文件处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> — canvas - show_pdf_page </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daemon.json的作用</title>
      <link href="/2025/01/21/daemon-json-de-zuo-yong/"/>
      <url>/2025/01/21/daemon-json-de-zuo-yong/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker数据卷volume</title>
      <link href="/2024/12/07/docker/docker-shu-ju-juan-volume/"/>
      <url>/2024/12/07/docker/docker-shu-ju-juan-volume/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>命名的容器挂载数据卷，其他容器通过挂载这个父容器来实现数据共享，挂载数据卷的容器称为数据卷容器，以下二、三主要讲与宿主机挂载容器数据卷。四讲其他容器通过volumes-from来挂载父容器来实现数据共享。</p><blockquote><p>通俗点容器数据卷是将docker中的容器(container)中产生的数据持久化到宿主机文件中并实现数据共享,其他容器可以通过数据卷来链接到这个容器，实现数据共享。</p></blockquote><p><strong>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</strong></p><p>数据卷的特点:</p><ol><li><p>数据卷可在容器之间共享或重用数据</p></li><li><p>卷中的更改可以直接生效</p></li><li><p>数据卷中的更改不会包含在镜像的更新中</p></li><li><p>数据卷的生命周期一直持续到没有容器使用它为止</p><p><img src="/../../images/978ffb8073d4c1dbbfe5881422237fb7000c30.png" alt="图片"></p></li></ol><h3 id="2-管理卷"><a href="#2-管理卷" class="headerlink" title="2. 管理卷"></a>2. 管理卷</h3><p> 存储卷可以通过命令方式创建，也可以在创建容器的时候通过 <code>-v </code>and <code>--mount</code> 指定。</p><h3 id="2-1-Volume-命令操作"><a href="#2-1-Volume-命令操作" class="headerlink" title="2.1 Volume 命令操作"></a>2.1 Volume 命令操作</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>docker volume create</td><td>创建存储卷</td></tr><tr><td>docker volume inspect</td><td>显示存储卷详细信息</td></tr><tr><td>docker volume ls</td><td>列出存储卷</td></tr><tr><td>docker volume prune</td><td>清理所有无用数据卷</td></tr><tr><td>docker volume rm</td><td>删除卷，使用中的无法删除</td></tr></tbody></table><h4 id="2-1-1-docker-volume-create"><a href="#2-1-1-docker-volume-create" class="headerlink" title="2.1.1 docker volume create"></a>2.1.1 docker volume create</h4><ul><li>功能：创建存储卷</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create [OPTIONS] [VOLUME]</span><br></pre></td></tr></tbody></table></figure><ul><li>参数：<ul><li>-d：指定驱动，默认是 local</li><li>–label：指定元数据（标签，给卷添一些备注信息）</li></ul></li></ul><p><img src="/../../images/image-20241207224404984.png" alt="image-20241207224404984"></p><p> 通过这种方式创建出来的卷的默认的目录是<code>/data/var/lib/docker/volumes/</code>。</p><p><img src="/../../images/image-2024120722440494.png"></p><p><code>--label</code> 是设置卷的备注信息。</p><p><img src="/../../images/8c72fd7de01b41cd877b97d0201df3f3" alt="image-20240213214447049"></p><h4 id="2-1-2-docker-volume-inspect"><a href="#2-1-2-docker-volume-inspect" class="headerlink" title="2.1.2 docker volume inspect"></a>2.1.2 docker volume inspect</h4><ul><li><p>功能：查看卷详细信息（上面的演示）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect VOLUME</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="2-1-3-docker-volume-ls"><a href="#2-1-3-docker-volume-ls" class="headerlink" title="2.1.3 docker volume ls"></a>2.1.3 docker volume ls</h4><ul><li><p>功能：列出所有的卷</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls [OPTIONS]</span><br></pre></td></tr></tbody></table></figure><ul><li><p>参数：</p><ul><li><p>–format：指定相应个格式，如 json,table</p></li><li><p>-f：过滤</p></li><li><p>-q：仅显示名称</p><p><img src="/../../images/5ff9eb80e92045ddbc8150f6ab7b439" alt="image-20240213220014550"></p></li></ul></li></ul><h4 id="2-1-4-docker-volume-rm"><a href="#2-1-4-docker-volume-rm" class="headerlink" title="2.1.4 docker volume rm"></a>2.1.4 docker volume rm</h4><ul><li>功能：删除卷，需要容器不使用。</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm [OPTIONS] VOLUME [VOLUME...]</span><br></pre></td></tr></tbody></table></figure><ul><li>参数：-f:强制删除</li></ul><p><img src="/../../images/58bdc53e83e74e8eada070a82b1b03a5" alt="image-20240213221204816"></p><h4 id="2-1-5-docker-volume-prune"><a href="#2-1-5-docker-volume-prune" class="headerlink" title="2.1.5 docker volume prune"></a>2.1.5 docker volume prune</h4><ul><li>功能：删除不使用的本地卷</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune [OPTIONS]</span><br></pre></td></tr></tbody></table></figure><ul><li>参数：<ul><li>–filter:过滤</li><li>-f:不提示是否删除</li></ul></li></ul><h3 id="2-2-v-或者–mount-指定"><a href="#2-2-v-或者–mount-指定" class="headerlink" title="2.2  -v 或者–mount 指定"></a>2.2  -v 或者–mount 指定</h3><h4 id="2-2-1-V-参数"><a href="#2-2-1-V-参数" class="headerlink" title="2.2.1 -V 参数"></a>2.2.1 -V 参数</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v name:directory[:options]</span><br></pre></td></tr></tbody></table></figure><ul><li>参数<ul><li>第一个参数：卷名称</li><li>第二个参数：卷映射到容器的目录</li><li>第三个参数：选项，如 <code>ro</code> 表示 <code>readonly</code>（表示只读，不允许删除容器中的文件）</li></ul></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行一个容器</span></span><br><span class="line">docker run -d --name mynginx2 -v volnginx2:/user/share/nginx/html/ nginx:1.24.0</span><br></pre></td></tr></tbody></table></figure><p>  运行一个容器，将容器<code>/user/share/nginx/html/</code>目录下的文件<code>自动拷贝</code>到<code>volnginx1</code>卷上（自己创建这个卷）。</p><p><img src="/../../images/5ec1072e5be440a4bddf083b0958ea9a" alt="image-20240214164117096"></p><p><img src="/../../images/c9ffd6f249884420a11b1e87a760ad7" alt="image-20240214164801567"></p><ul><li>如果删除容器中的文件，宿主机将会跟着删除。</li></ul><p><img src="/../../images/4b6bf2f2e21b488dab4a092e83c485c8" alt="image-20240214165059819"></p><p>  为了避免上面的这种情况，就要加上 <code>:ro </code> 就可避免<code>容器</code>中的文件被删除。<code>ro</code>它表示只读，可以修改宿主机的文件，但是容器里的文件修改不了。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mynginx2 -v volnginx2:/user/share/nginx/html/:ro nginx:1.24.0</span><br></pre></td></tr></tbody></table></figure><h4 id="2-2-2-–mount-参数"><a href="#2-2-2-–mount-参数" class="headerlink" title="2.2.2 –mount 参数"></a>2.2.2 –mount 参数</h4><ul><li>功能：完成目录映射</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--mount '&lt;key&gt;=&lt;value&gt;,&lt;key&gt;=&lt;value&gt;'</span><br></pre></td></tr></tbody></table></figure><ul><li>参数：<ul><li><code>type</code>：类型表示 <code>bind, volume, tmpfs</code>。</li><li><code>src</code>：对于命名卷，这是卷的名称。对于匿名卷（名称为一串字符串），省略此字段。</li><li><code>dst</code>,<code>target</code>：文件或目录挂载在容器中的路径。</li><li><code>ro</code>,<code>readonly</code>：只读方式挂载。</li></ul></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mynginx4 --mount 'src=nginxvol4,dst=/usr/share/nginx/html,ro' nginx:1.24.0</span><br></pre></td></tr></tbody></table></figure><p>  将容器中<code>/usr/share/nginx/html</code>目录下的文件与<code>nginxvol4</code>卷相映射。</p><blockquote><ol><li>如果删除容器，卷是不会删除的，也就说宿主机中的文件会保留（这也是卷的作用）。</li><li>如果修改宿主机中的文件，容器里的文件会自动更新（前提是容器不是只读模式）。</li></ol></blockquote><h2 id="3-绑定卷"><a href="#3-绑定卷" class="headerlink" title="3 绑定卷"></a>3 绑定卷</h2><p>  绑定卷跟管理卷中的 -v、––mount是一样的。</p><h3 id="3-1-v-参数创建卷"><a href="#3-1-v-参数创建卷" class="headerlink" title="3.1 -v 参数创建卷"></a>3.1 -v 参数创建卷</h3><ul><li>功能：完成卷映射</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v name:directory[:options]</span><br></pre></td></tr></tbody></table></figure><ul><li>参数：<ul><li>第一个参数：宿主机目录，这个和管理卷是不一样的。(随着写法变动)</li><li>第二个参数：卷映射到容器的目录。</li><li>第三个参数：选项，如 <code>ro</code> 表示 <code>readonly</code>。</li></ul></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行并绑定</span></span><br><span class="line">docker run -d --name mynginx6 -v /root/data:/usr/share/nginx/html nginx:1.24.0</span><br></pre></td></tr></tbody></table></figure><p>  这时候就是将宿主机中的<code>/root/data</code>目录与容器中的<code>/usr/share/nginx/html</code>目录相绑定。这时候容器中的初始文件消失了（index.html）。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看详细信息</span></span><br><span class="line">docker inspect mynginx6</span><br></pre></td></tr></tbody></table></figure><p><img src="/../../images/6e1b8be1e5e740da861f2d13d01b4fa1" alt="image-20240215104224393"></p><h3 id="3-2-–mount-参数"><a href="#3-2-–mount-参数" class="headerlink" title="3.2 –mount 参数"></a>3.2 –mount 参数</h3><p>  这跟 <code>-v</code> 是很相似的，就是<code>将卷的名称替换为宿主机的目录</code>，区别是一定要加上<code>type</code>参数，<code>bind</code> 表示绑定卷。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name myngixn7  --mount type=bind,src=/root/data,dst=/usr/share/nginx/html nginx:1.24.0</span><br></pre></td></tr></tbody></table></figure><blockquote><p>-v 与 –mount 的区别： -v 创建卷的时候，宿主机的目录可以不用存在；而 –mount 必须先创建目录再绑定，不然会报错。</p></blockquote><h2 id="4-临时卷"><a href="#4-临时卷" class="headerlink" title="4.临时卷"></a>4.临时卷</h2><p>  临时卷数据位于内存中，在容器与宿主机之外。</p><h3 id="4-1-指定-–tmpfs-创建"><a href="#4-1-指定-–tmpfs-创建" class="headerlink" title="4.1 指定 –tmpfs 创建"></a>4.1 指定 –tmpfs 创建</h3><p>  在创建一个临时目录<code>/test1</code></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mynginx8 -d --tmpfs /test1 nginx:1.24.0</span><br></pre></td></tr></tbody></table></figure><p>  可以通过 <code>docker inspect mynginx8</code> 来查看。</p><p><img src="/../../images/9b864af239574d6eb5d0dfac44421448" alt="image-20240215114732051"></p><p>   <code>/test1</code> 在容器的目录中，但是数据是存储在内存中的。如果容器重启，那么该目录下的。</p><p><img src="/../../images/7dc504673a9f442b8d7145f0d51c8686" alt="image-20240215115148428"></p><h3 id="4-2-–mount-参数"><a href="#4-2-–mount-参数" class="headerlink" title="4.2 –mount 参数"></a>4.2 –mount 参数</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--mount '&lt;key&gt;=&lt;value&gt;,&lt;key&gt;=&lt;value&gt;'</span><br></pre></td></tr></tbody></table></figure><ul><li>参数：<ul><li>type：类型表示 bind, volume,tmpfs。</li><li>src：宿主机目录，这个和管理卷是不一样的。</li><li>dst,target：文件或目录挂载在容器中的路径。</li><li>ro,readonly：只读方式挂载。</li></ul></li></ul><p>  只需要 <code>type</code> 类型为 <code>tmpfs</code> 就行了。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 --name bind1 --mount type=tmpfs,source=/root/data,target=/usr/share/nginx/html nginx:1.24.0</span><br></pre></td></tr></tbody></table></figure></li></ul><p>摘自<a href="https://juejin.cn/post/7335067315451330569">https://juejin.cn/post/7335067315451330569</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的网络基础</title>
      <link href="/2024/12/07/docker/docker-de-wang-luo-ji-chu/"/>
      <url>/2024/12/07/docker/docker-de-wang-luo-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Docker-网络命令大全"><a href="#1-Docker-网络命令大全" class="headerlink" title="1.Docker 网络命令大全"></a>1.Docker 网络命令大全</h1><ul><li><code>docker network connect</code></li><li><code>docker network create</code></li><li><code>docker network disconnect</code></li><li><code>docker network inspect</code></li><li><code>docker network ls</code></li><li><code>docker network prune</code></li><li><code>docker network rm</code></li></ul><h2 id="Docker-Network-Connect"><a href="#Docker-Network-Connect" class="headerlink" title="Docker Network Connect"></a>Docker Network Connect</h2><p><code>docker network connect</code> 命令用于将一个容器连接到一个网络中。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect [OPTIONS] NETWORK CONTAINER</span><br></pre></td></tr></tbody></table></figure><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li><code>NETWORK</code>：要连接的网络名称或ID。</li><li><code>CONTAINER</code>：要连接到网络的容器名称或ID。</li></ul><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><ol><li>将容器连接到默认网络：</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect bridge container_name</span><br></pre></td></tr></tbody></table></figure><ol><li>将容器连接到指定网络：</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect my_network container_name</span><br></pre></td></tr></tbody></table></figure><ul><li>该命令允许将一个容器连接到一个已存在的网络中，使得容器可以与该网络上的其他容器进行通信。</li><li>当容器连接到网络时，它将被分配一个IP地址，并且可以与网络上的其他容器进行通信。</li><li>连接到网络后，容器可以访问网络上其他容器的服务，也可以被其他容器访问。</li><li>容器连接到网络后，可能需要重启容器才能应用网络配置。</li><li>如果网络不存在，可以使用 <code>docker network create</code> 命令创建网络。</li></ul><h2 id="Docker-Network-Disconnect"><a href="#Docker-Network-Disconnect" class="headerlink" title="Docker Network Disconnect"></a>Docker Network Disconnect</h2><p><code>docker network disconnect</code> 命令用于将容器从一个网络中断开连接。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect [OPTIONS] NETWORK CONTAINER</span><br></pre></td></tr></tbody></table></figure><h3 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li><code>NETWORK</code>：要断开连接的网络名称或ID。</li><li><code>CONTAINER</code>：要断开连接的容器名称或ID。</li></ul><h3 id="用法示例-1"><a href="#用法示例-1" class="headerlink" title="用法示例"></a>用法示例</h3><ol><li>从默认桥接网络中断开容器：</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect bridge container_name</span><br></pre></td></tr></tbody></table></figure><ol><li>从指定网络中断开容器：</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect my_network container_name</span><br></pre></td></tr></tbody></table></figure><ul><li>该命令允许将容器从一个已连接的网络中断开，使得容器不再能够与该网络上的其他容器进行通信。</li><li>断开连接后，容器将失去与网络上其他容器的通信能力，但仍然可以与主机进行通信。</li><li>断开连接后，容器可能需要重启才能应用新的网络配置。</li><li>如果需要，断开连接后可以重新连接到网络。</li></ul><h2 id="Docker-Network-Inspect"><a href="#Docker-Network-Inspect" class="headerlink" title="Docker Network Inspect"></a>Docker Network Inspect</h2><p><code>docker network inspect</code> 命令用于检查 Docker 网络的详细信息。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect [OPTIONS] NETWORK [NETWORK...]</span><br></pre></td></tr></tbody></table></figure><h3 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li><code>NETWORK</code>：要检查的网络名称或ID。</li></ul><h3 id="用法示例-2"><a href="#用法示例-2" class="headerlink" title="用法示例"></a>用法示例</h3><ol><li>检查指定网络的详细信息：</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect my_network</span><br></pre></td></tr></tbody></table></figure><ol><li>检查多个网络的详细信息：</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect network1 network2</span><br></pre></td></tr></tbody></table></figure><ul><li>该命令允许查看指定网络的配置和状态信息，包括网络的名称、ID、驱动程序、子网、网关、连接的容器等。</li><li>可以同时指定多个网络进行检查。</li><li>使用该命令需要指定网络的名称或ID。</li><li>输出结果为 JSON 格式，可以使用 <code>jq</code> 等工具进行格式化或解析。</li></ul><h2 id="Docker-Network-LS"><a href="#Docker-Network-LS" class="headerlink" title="Docker Network LS"></a>Docker Network LS</h2><p><code>docker network ls</code> 命令用于列出 Docker 中的网络。</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span> [OPTIONS]</span><br></pre></td></tr></tbody></table></figure><h3 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li>该命令没有特定的参数，但可以使用一些选项来过滤输出结果。</li></ul><h3 id="用法示例-3"><a href="#用法示例-3" class="headerlink" title="用法示例"></a>用法示例</h3><ol><li>列出所有网络：</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span></span><br></pre></td></tr></tbody></table></figure><ol><li>仅列出特定驱动程序类型的网络：</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span> --filter driver=bridge</span><br></pre></td></tr></tbody></table></figure><ul><li>该命令用于快速查看 Docker 中存在的所有网络，包括桥接网络、覆盖网络等。</li><li>输出结果包含每个网络的名称、ID、驱动程序类型、创建时间等信息。</li><li>使用该命令可以快速了解 Docker 中当前存在的网络情况。</li><li>可以通过 <code>--filter</code> 选项来过滤输出结果，以便根据特定条件查找网络。</li></ul><h2 id="Docker-Network-Prune"><a href="#Docker-Network-Prune" class="headerlink" title="Docker Network Prune"></a>Docker Network Prune</h2><p><code>docker network prune</code> 命令用于清理未使用的 Docker 网络。</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network prune [OPTIONS]</span><br></pre></td></tr></tbody></table></figure><h3 id="参数说明-4"><a href="#参数说明-4" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li>该命令没有特定的参数，但可以使用一些选项来调整清理的行为。</li></ul><h3 id="用法示例-4"><a href="#用法示例-4" class="headerlink" title="用法示例"></a>用法示例</h3><ol><li>清理未使用的网络：</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network prune</span><br></pre></td></tr></tbody></table></figure><ol><li>在清理之前显示将要删除的网络列表：</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network prune --dry-run</span><br></pre></td></tr></tbody></table></figure><ul><li>该命令用于删除未连接到任何容器的网络，以释放系统资源。</li><li>在执行清理操作之前，建议使用 <code>--dry-run</code> 选项来查看将要删除的网络列表，以避免意外删除重要网络。</li><li>清理操作是不可逆的，删除的网络无法恢复。</li><li>建议在清理之前先确保没有需要保留的网络。</li></ul><h2 id="Docker-Network-RM"><a href="#Docker-Network-RM" class="headerlink" title="Docker Network RM"></a>Docker Network RM</h2><p><code>docker network rm</code> 命令用于删除指定的 Docker 网络。</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">rm</span> NETWORK [NETWORK...]</span><br></pre></td></tr></tbody></table></figure><h3 id="参数说明-5"><a href="#参数说明-5" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li><code>NETWORK</code>：要删除的网络名称或ID。</li></ul><h3 id="用法示例-5"><a href="#用法示例-5" class="headerlink" title="用法示例"></a>用法示例</h3><ol><li>删除单个网络：</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">rm</span> my_network</span><br></pre></td></tr></tbody></table></figure><ol><li>删除多个网络：</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">rm</span> network1 network2</span><br></pre></td></tr></tbody></table></figure><ul><li>该命令用于删除指定的 Docker 网络，可以一次删除一个或多个网络。</li><li>在删除网络之前，请确保网络中没有正在运行的容器连接到该网络，否则删除操作将失败。</li><li>删除操作是不可逆的，删除的网络无法恢复。</li><li>在删除网络之前，请确保网络不再需要，并且其中没有重要的数据。</li></ul><h1 id="2-Docker的网络基础"><a href="#2-Docker的网络基础" class="headerlink" title="2. Docker的网络基础"></a>2. Docker的网络基础</h1><h2 id="2-1-Network-Namespace"><a href="#2-1-Network-Namespace" class="headerlink" title="2.1. Network Namespace"></a>2.1. Network Namespace</h2><p>不同的网络命名空间中，协议栈是独立的，完全隔离，彼此之间无法通信。同一个网络命名空间有独立的路由表和独立的<code>Iptables/Netfilter</code>来提供包的转发、NAT、IP包过滤等功能。</p><h3 id="2-1-1-网络命名空间的实现"><a href="#2-1-1-网络命名空间的实现" class="headerlink" title="2.1.1. 网络命名空间的实现"></a>2.1.1. 网络命名空间的实现</h3><p>将与网络协议栈相关的全局变量变成一个<code>Net Namespace</code>变量的成员，然后在调用协议栈函数中加入一个Namepace参数。</p><h3 id="2-1-2-网络命名空间的操作"><a href="#2-1-2-网络命名空间的操作" class="headerlink" title="2.1.2. 网络命名空间的操作"></a>2.1.2. 网络命名空间的操作</h3><p>1、创建网络命名空间</p><p>ip netns add <code>name</code></p><p>2、在命名空间内执行命令</p><p>ip netns exec <code>name</code> <code>command</code></p><p>3、进入命名空间</p><p>ip netns exec <code>name</code> bash</p><h1 id="3-Docker的网络实现"><a href="#3-Docker的网络实现" class="headerlink" title="3. Docker的网络实现"></a>3. Docker的网络实现</h1><h2 id="3-1-容器网络"><a href="#3-1-容器网络" class="headerlink" title="3.1. 容器网络"></a>3.1. 容器网络</h2><p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p><p>Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。<img src="/../../images/container-network.png" alt="这里写图片描述">   </p><p>​</p><h2 id="3-2-4类网络模式"><a href="#3-2-4类网络模式" class="headerlink" title="3.2.  4类网络模式"></a>3.2.  4类网络模式</h2><table><thead><tr><th>Docker网络模式</th><th>配置</th><th>说明</th></tr></thead><tbody><tr><td>host模式</td><td>–net=host</td><td>容器和宿主机共享Network namespace。</td></tr><tr><td>container模式</td><td>–net=container:NAME_or_ID</td><td>容器和另外一个容器共享Network namespace。 kubernetes中的pod就是多个容器共享一个Network namespace。</td></tr><tr><td>none模式</td><td>–net=none</td><td>容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。</td></tr><tr><td>bridge模式</td><td>–net=bridge（默认为该模式）</td><td>桥接模式</td></tr></tbody></table><h1 id="4-Docker网络模式"><a href="#4-Docker网络模式" class="headerlink" title="4. Docker网络模式"></a>4. Docker网络模式</h1><h2 id="4-1-bridge桥接模式"><a href="#4-1-bridge桥接模式" class="headerlink" title="4.1. bridge桥接模式"></a>4.1. bridge桥接模式</h2><p>在bridge模式下，Docker可以使用独立的网络栈。实现方式是父进程在创建子进程的时候通过传入<code>CLONE_NEWNET</code>的参数创建出一个网络命名空间。</p><p><strong>实现步骤：</strong></p><ol><li>Docker Daemon首次启动时会创建一个虚拟网桥docker0，地址通常为172.x.x.x开头，在私有的网络空间中给这个网络分配一个子网。</li><li>由Docker创建处理的每个容器，都会创建一个虚拟以太设备对（veth pair），一端关联到网桥，另一端使用Namespace技术映射到容器内的eth0设备，然后从网桥的地址段内给eth0接口分配一个IP地址。</li></ol><p><img src="/../../images/bridge.png" alt="这里写图片描述"></p><p>一般情况，宿主机IP与docker0 IP、容器IP是不同的IP段，默认情况，外部看不到docker0和容器IP，对于外部来说相当于docker0和容器的IP为内网IP。</p><h3 id="4-1-1-外部网络访问Docker容器"><a href="#4-1-1-外部网络访问Docker容器" class="headerlink" title="4.1.1. 外部网络访问Docker容器"></a>4.1.1. 外部网络访问Docker容器</h3><p>外部访问docker容器可以通过<code>端口映射(NAT)</code>的方式，Docker使用NAT的方式将容器内部的服务与宿主机的某个端口port_1绑定。</p><p>外部访问容器的流程如下：</p><ol><li>外界网络通过宿主机的IP和映射的端口port_1访问。</li><li>当宿主机收到此类请求，会通过DNAT将请求的目标IP即宿主机IP和目标端口即映射端口port_1替换成容器的IP和容器的端口port_0。</li><li>由于宿主机上可以识别容器IP，所以宿主机将请求发给veth pair。</li><li>veth pair将请求发送给容器内部的eth0，由容器内部的服务进行处理。</li></ol><h3 id="4-1-2-Docker容器访问外部网络"><a href="#4-1-2-Docker容器访问外部网络" class="headerlink" title="4.1.2. Docker容器访问外部网络"></a>4.1.2. Docker容器访问外部网络</h3><p>docker容器访问外部网络的流程：</p><ol><li>docker容器向外部目标IP和目标端口port_2发起请求，请求报文中的源IP为容器IP。</li><li>请求通过容器内部的eth0到veth pair的另一端docker0网桥。</li><li>docker0网桥通过数据报转发功能将请求转发到宿主机的eth0。</li><li>宿主机处理请求时通过SNAT将请求中的源IP换成宿主机eth0的IP。</li><li>处理后的报文通过请求的目标IP发送到外部网络。</li></ol><h3 id="4-1-3-缺点"><a href="#4-1-3-缺点" class="headerlink" title="4.1.3. 缺点"></a>4.1.3. 缺点</h3><p>使用NAT的方式可能会带来性能的问题，影响网络传输效率。</p><h2 id="4-2-host模式"><a href="#4-2-host模式" class="headerlink" title="4.2. host模式"></a>4.2. host模式</h2><p>host模式并没有给容器创建一个隔离的网络环境，而是和宿主机共用一个网络命名空间，容器使用宿主机的eth0和外界进行通信，同样容器也共用宿主机的端口资源，即分配端口可能存在与宿主机已分配的端口冲突的问题。</p><p>实现的方式即父进程在创建子进程的时候不传入<code>CLONE_NEWNET</code>的参数，从而和宿主机共享一个网络空间。</p><p>host模式没有通过NAT的方式进行转发因此性能上相对较好，但是不存在网络隔离性，可能产生端口冲突的问题。</p><h2 id="4-3-container模式"><a href="#4-3-container模式" class="headerlink" title="4.3. container模式"></a>4.3. container模式</h2><p>container模式即docker容器可以使用其他容器的网络命名空间，即和其他容器处于同一个网络命名空间。</p><p>步骤：</p><ol><li>查找其他容器的网络命名空间。</li><li>新创建的容器的网络命名空间使用其他容器的网络命名空间。</li></ol><p>通过和其他容器共享网络命名空间的方式，可以让不同的容器之间处于相同的网络命名空间，可以直接通过localhost的方式进行通信，简化了强关联的多个容器之间的通信问题。</p><p>k8s中的pod的概念就是通过一组容器共享一个网络命名空间来达到pod内部的不同容器可以直接通过localhost的方式进行通信。</p><h2 id="4-4-none模式"><a href="#4-4-none模式" class="headerlink" title="4.4. none模式"></a>4.4. none模式</h2><p>none模式即不为容器创建任何的网络环境，用户可以根据自己的需要手动去创建不同的网络定制配置。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底删除k8s</title>
      <link href="/2024/12/03/k8s/che-di-shan-chu-k8s/"/>
      <url>/2024/12/03/k8s/che-di-shan-chu-k8s/</url>
      
        <content type="html"><![CDATA[<p>在开始卸载Kubernetes（k8s）之前，请确保您已经停止了所有Kubernetes节点的服务。接下来，我们将按照以下步骤进行彻底卸载：<br>步骤1：停止Kubernetes服务<br>在每个Kubernetes节点上，执行以下命令停止Kubernetes服务：<br>停止kubelet服务：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop kubelet</span><br></pre></td></tr></tbody></table></figure><p>停止etcd服务：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop etcd</span><br></pre></td></tr></tbody></table></figure><p>停止Docker服务（如果安装了Docker）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></tbody></table></figure><p>步骤2：清除Kubernetes集群配置<br>在<strong>每个Kubernetes节点上</strong>，执行以下命令清除Kubernetes集群配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset -f</span><br></pre></td></tr></tbody></table></figure><p>步骤3：删除Kubernetes相关软件包<br>在每个Kubernetes节点上，执行以下命令删除Kubernetes相关软件包：<br>首先，列出已安装的与Kubernetes相关的软件包：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list installed | grep kube</span><br></pre></td></tr></tbody></table></figure><p>然后，卸载这些软件包。例如，卸载名为“kubelet”的软件包：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove kubelet</span><br></pre></td></tr></tbody></table></figure><p>请注意，根据您的系统配置，可能需要以管理员身份运行这些命令。在执行这些步骤时，请谨慎操作，确保不会误删其他重要软件。<br>除了上述基本卸载步骤外，根据您的系统配置和安装的组件，可能还需要执行其他额外的清理步骤。以下是一些可能的额外步骤：<br>步骤4：删除Kubelet配置文件和证书<br>在每个Kubernetes节点上，删除kubelet配置文件和证书。这些文件通常位于以下目录中：</p><ul><li><p><code>/etc/kubernetes/</code></p></li><li><p><code>/etc/systemd/system/kubelet.service.d/</code></p></li><li><pre><code>/etc/systemd/system/kubelet.service/<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用以下命令删除这些目录和文件：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>rm -rf /etc/kubernetes/ /etc/systemd/system/kubelet.service.d/ /etc/systemd/system/kubelet.service/ /etc/cni/ /opt/cni/ /var/lib/etcd/ /var/etcd/<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">步骤5：删除Docker容器和镜像</span><br><span class="line"></span><br><span class="line">如果您在卸载Kubernetes之前安装了Docker，请确保删除所有Docker容器和镜像。使用以下命令列出所有正在运行的容器：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>docker ps -a -q<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后，使用以下命令停止并删除这些容器：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>docker kill $(docker ps -a -q)docker rm $(docker ps -a -q)<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接下来，删除所有Docker镜像。请注意，这将删除您系统中所有的Docker镜像，包括其他非Kubernetes相关的镜像。确保您已经备份了重要的镜像。要删除所有镜像，请执行以下命令：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>docker rmi -f $(docker images -q)<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**清理残留的配置和证书**</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>\# 删除 Kubernetes 配置目录 rm -rf /etc/kubernetes/ # 删除 etcd 数据（如果存在） rm -rf /var/lib/etcd # 删除 kubelet 配置目录rm -rf $HOME/.kube # 删除 CNI 网络配置（如果存在） rm -rf /etc/cni/net.d # 删除 CNI 插件（如果存在） rm -rf /opt/cni/bin # 删除 kubelet 工作目录 rm -rf /var/lib/kubelet/*</code></pre><p>完成上述步骤后，您的Kubernetes集群及其相关组件应该已从系统中彻底删除。请记住，这些步骤仅适用于基于RPM的Linux发行版（如CentOS、Fedora、Red Hat等），如果您使用的是其他发行版或系统配置，请根据具体情况进行相应的调整。此外，如果您在卸载之前安装了其他与Kubernetes相关的组件或工具，也请确保在卸载过程中一并删除它们。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker save命令</title>
      <link href="/2024/12/02/docker/docker-save-ming-ling/"/>
      <url>/2024/12/02/docker/docker-save-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-save-命令"><a href="#Docker-save-命令" class="headerlink" title="Docker save 命令"></a>Docker save 命令</h1><p><code>docker save</code> 命令用于将一个或多个 Docker 镜像保存到一个 tar 归档文件中，以便在其他环境中分发或备份。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></tbody></table></figure><ul><li><strong><code>IMAGE</code></strong>: 要保存的一个或多个镜像名称或 ID。</li></ul><p>OPTIONS 说明：</p><ul><li><strong><code>-o, --output</code></strong>: 指定输出文件的路径。</li></ul><p>1、保存单个镜像到文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o myimage.tar myimage:latest</span><br></pre></td></tr></tbody></table></figure><p>这将 myimage:latest 镜像保存为 myimage.tar 文件。</p><p>2、保存多个镜像到同一个文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o multiple_images.tar myimage:latest anotherimage:latest</span><br></pre></td></tr></tbody></table></figure><p>这将 myimage:latest 和 anotherimage:latest 镜像保存到 multiple_images.tar 文件中。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="构建一个示例镜像"><a href="#构建一个示例镜像" class="headerlink" title="构建一个示例镜像"></a>构建一个示例镜像</h3><p>1、创建一个 Dockerfile：</p><figure class="highlight dockerfile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Ubuntu 作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加维护者信息</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">"yourname@example.com"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新包列表并安装 Nginx</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制自定义网页到 Nginx 的默认网页目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> index.html /var/www/html/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置启动时的默认命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span>]</span></span><br></pre></td></tr></tbody></table></figure><p>构建镜像：</p><figure class="highlight dockerfile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t mynginx:latest .</span><br></pre></td></tr></tbody></table></figure><p>2、保存镜像到文件</p><figure class="highlight do"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">save</span> -o mynginx.tar mynginx:latest</span><br></pre></td></tr></tbody></table></figure><p>这将 mynginx:latest 镜像保存为 mynginx.tar 文件。</p><p>3、验证保存的文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lh mynginx.tar</span><br></pre></td></tr></tbody></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 user user 200M Jul 24 14:00 mynginx.tar</span><br></pre></td></tr></tbody></table></figure><p>4、加载保存的镜像</p><p>要将保存的镜像加载到另一个 Docker 环境中，可以使用 docker load 命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i mynginx.tar</span><br></pre></td></tr></tbody></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>保存镜像时，会包含镜像的所有层，因此生成的 tar 文件可能会很大。</li><li>如果保存多个镜像到同一个文件中，使用 <code>docker load</code> 命令时会加载所有包含的镜像。</li><li>为了减少文件大小，可以在保存前使用 <code>docker image prune</code> 命令清理未使用的镜像和层。</li></ul><p><code>docker save</code> 命令是一个方便的工具，用于将 Docker 镜像保存为 tar 文件，以便于备份、分发和迁移。通过结合 <code>docker load</code> 命令，可以轻松地在不同环境中恢复和使用保存的镜像。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置IP地址时network 和networkmanager冲突</title>
      <link href="/2024/12/01/linux/pei-zhi-ip-di-zhi-shi-network-he-networkmanager-chong-tu/"/>
      <url>/2024/12/01/linux/pei-zhi-ip-di-zhi-shi-network-he-networkmanager-chong-tu/</url>
      
        <content type="html"><![CDATA[<p>一、区别<br>1、network service的制御网络接口配置信息改动后，网络服务必须从新启动，来激活网络新配置的使得配置生效，这部分操作和从新启动系统时时一样的作用。制御（控制）是/etc/init.d/network这个文件，可以用这个文件后面加上下面的参数来操作网络服务。<br>2、(NetworManager)是检测网络、自动连接网络的程序。无论是无线还是有线连接，它都可以令您轻松管理。对于无线网络,网络管理器可以自动切换到最可靠的无线网络。利用网络管理器的程序可以自由切换在线和离线模式。网络管理器可以优先选择有线网络，支持 VPN。网络管理器最初由 Redhat 公司开发，现在由 GNOME 管理。<br>二、原因<br>NetworkManager是fedora上的一个网络地址服务，它会自动地检测目前网络上的设置，并自动修改设置文件的内容，如无线网络的检测等。<br>但当它无法识别时，就会产生无法联机的状况，因此建议将NetworkManager停用并开启network服务.二者都可以配置网络服务.<br>三、解决办法<br>1、 将NetworkManager 服务设置开机不启动<br>chkconfig NetworkManager off<br>2、将NetwokManager服务关闭<br>service NetworkManager stop<br>3、重新启动一下network服务<br>service network restart</p>]]></content>
      
      
      <categories>
          
          <category> Centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos </tag>
            
            <tag> 配置Ip地址 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Gin中实现跨域</title>
      <link href="/2024/11/30/goland/zai-gin-zhong-shi-xian-kua-yu/"/>
      <url>/2024/11/30/goland/zai-gin-zhong-shi-xian-kua-yu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是CORS？"><a href="#1-什么是CORS？" class="headerlink" title="1. 什么是CORS？"></a>1. 什么是CORS？</h3><p><strong>跨域资源共享（CORS, Cross-Origin Resource Sharing）</strong> 是一种浏览器机制，允许受限资源（如字体、JavaScript等）在一个（源）下的网页被另一个域（源）的网页所请求。它是一种在浏览器中实现跨域请求的标准方式。</p><p><strong>为什么需要CORS？</strong></p><p>浏览器的<strong>同源策略（Same-Origin Policy）</strong>限制了网页从不同源加载资源，这是一种安全机制，防止恶意网站窃取敏感信息。然而，在现代Web开发中，前后端分离、微服务架构等需求使得跨域请求变得普遍，CORS为这种需求提供了标准化的解决方案。</p><p>当构建Web应用程序时，可能需要在不同域之间进行数据交换，这就涉及到跨域资源共享（CORS）。在Gin框架中实现跨域是一个常见的需求。</p><p>​跨域资源共享（CORS）是一种浏览器安全机制，用于控制不同域之间的资源共享。在Gin中，你可以使用中间件来配置CORS策略，允许或拒绝特定的跨域请求。</p><p>​以下是在Gin中实现跨域的步骤：</p><h3 id="2-导入Gin和CORS包"><a href="#2-导入Gin和CORS包" class="headerlink" title="2. 导入Gin和CORS包"></a><strong>2. 导入Gin和CORS包</strong></h3><p>​首先，先确保已经安装了Gin和Cors的Go模块。可以使用以下命令安装</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/gin-gonic/gin</span><br><span class="line"><span class="keyword">go</span> get -u github.com/gin-contrib/cors</span><br></pre></td></tr></tbody></table></figure><h3 id="3-创建一个Gin应用"><a href="#3-创建一个Gin应用" class="headerlink" title="3. 创建一个Gin应用"></a><strong>3. 创建一个Gin应用</strong></h3><p>在Go代码中，导入Gin和Cors模块并创建一个Gin应用：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">    <span class="string">"github.com/gin-contrib/cors"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用CORS中间件</span></span><br><span class="line">    r.Use(cors.Default())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义路由和处理程序</span></span><br><span class="line">    r.GET(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H{</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"Hello, CORS!"</span>,</span><br><span class="line">        })</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    r.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-配置CORS中间件"><a href="#4-配置CORS中间件" class="headerlink" title="4. 配置CORS中间件"></a><strong>4. 配置CORS中间件</strong></h3><p>在上面的代码中，通过使用<code>cors.Default()</code>中间件来启用CORS支持。这将允许来自任何源的GET，POST和OPTIONS请求，并允许特定的标头和方法。</p><p>你还可以根据需要配置CORS中间件。例如，以下代码将限制跨域请求只能来自指定的域名：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"github.com/gin-contrib/cors"</span></span><br><span class="line">  <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  router := gin.Default()</span><br><span class="line">  <span class="comment">// CORS for https://foo.com and https://github.com origins, allowing:</span></span><br><span class="line">  <span class="comment">// - PUT and PATCH methods</span></span><br><span class="line">  <span class="comment">// - Origin header</span></span><br><span class="line">  <span class="comment">// - Credentials share</span></span><br><span class="line">  <span class="comment">// - Preflight requests cached for 12 hours</span></span><br><span class="line">  router.Use(cors.New(cors.Config{</span><br><span class="line">    AllowOrigins:     []<span class="type">string</span>{<span class="string">"https://foo.com"</span>},</span><br><span class="line">    AllowMethods:     []<span class="type">string</span>{<span class="string">"PUT"</span>, <span class="string">"PATCH"</span>},</span><br><span class="line">    AllowHeaders:     []<span class="type">string</span>{<span class="string">"Origin"</span>},</span><br><span class="line">    ExposeHeaders:    []<span class="type">string</span>{<span class="string">"Content-Length"</span>},</span><br><span class="line">    AllowCredentials: <span class="literal">true</span>,</span><br><span class="line">    AllowOriginFunc: <span class="function"><span class="keyword">func</span><span class="params">(origin <span class="type">string</span>)</span></span> <span class="type">bool</span> {</span><br><span class="line">      <span class="keyword">return</span> origin == <span class="string">"https://github.com"</span></span><br><span class="line">    },</span><br><span class="line">    MaxAge: <span class="number">12</span> * time.Hour,</span><br><span class="line">  }))</span><br><span class="line">  router.Run()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另一种使用方法：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> router</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/gin-contrib/cors"</span></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetupRouter 初始化并返回 Gin 引擎</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupRouter</span><span class="params">()</span></span> *gin.Engine {</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 DefaultConfig 作为起点</span></span><br><span class="line">    corsConfig := cors.DefaultConfig()</span><br><span class="line">    corsConfig.AllowOrigins = []<span class="type">string</span>{<span class="string">"http://localhost:8080"</span>} <span class="comment">// 设置允许的源</span></span><br><span class="line">    corsConfig.AllowMethods = []<span class="type">string</span>{<span class="string">"GET"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>, <span class="string">"OPTIONS"</span>}</span><br><span class="line">    corsConfig.AllowHeaders = []<span class="type">string</span>{<span class="string">"Origin"</span>, <span class="string">"Content-Type"</span>, <span class="string">"Authorization"</span>}</span><br><span class="line">    corsConfig.AllowCredentials = <span class="literal">true</span></span><br><span class="line">    corsConfig.MaxAge = <span class="number">12</span> * time.Hour</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用自定义的 CORS 配置</span></span><br><span class="line">    router.Use(cors.New(corsConfig))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册路由</span></span><br><span class="line">    RegisterAuthRoutes(router)</span><br><span class="line">    RegisterAPIRoutes(router)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> router</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="5-CORS配置参数详解"><a href="#5-CORS配置参数详解" class="headerlink" title="5. CORS配置参数详解"></a>5. CORS配置参数详解</h2><p>以下是<code>gin-contrib/cors</code>库中<code>cors.Config</code>结构体的主要字段及其作用：</p><h3 id="5-1-AllowOrigins"><a href="#5-1-AllowOrigins" class="headerlink" title="5.1 AllowOrigins"></a>5.1 AllowOrigins</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllowOrigins []string</span><br></pre></td></tr></tbody></table></figure><p><strong>说明：</strong> 指定允许的源（域名）。例如，<code>http://localhost:8080</code> 或 <code>https://yourdomain.com</code>。不建议在生产环境中使用<code>"*"</code>，因为它允许所有域名访问，存在安全风险。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllowOrigins: []string{"http://localhost:8080", "https://yourdomain.com"},</span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-AllowOriginFunc"><a href="#5-2-AllowOriginFunc" class="headerlink" title="5.2 AllowOriginFunc"></a>5.2 AllowOriginFunc</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllowOriginFunc func(origin string) bool</span><br></pre></td></tr></tbody></table></figure><p><strong>说明：</strong> 允许通过自定义函数来动态判断是否允许某个源。可以用于复杂的验证逻辑。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go复制代码AllowOriginFunc: func(origin string) bool {</span><br><span class="line">    return origin == "http://localhost:8080" || origin == "https://yourdomain.com"</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><h3 id="5-3-AllowMethods"><a href="#5-3-AllowMethods" class="headerlink" title="5.3 AllowMethods"></a>5.3 AllowMethods</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllowMethods []string</span><br></pre></td></tr></tbody></table></figure><p><strong>说明：</strong> 指定允许的HTTP方法，如<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>等。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllowMethods: []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},</span><br></pre></td></tr></tbody></table></figure><h3 id="5-4-AllowHeaders"><a href="#5-4-AllowHeaders" class="headerlink" title="5.4 AllowHeaders"></a>5.4 AllowHeaders</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllowHeaders []string</span><br></pre></td></tr></tbody></table></figure><p><strong>说明：</strong> 指定允许的请求头。例如，<code>Content-Type</code>、<code>Authorization</code>等。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllowHeaders: []string{"Origin", "Content-Type", "Authorization"},</span><br></pre></td></tr></tbody></table></figure><h3 id="5-5-ExposeHeaders"><a href="#5-5-ExposeHeaders" class="headerlink" title="5.5 ExposeHeaders"></a>5.5 ExposeHeaders</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExposeHeaders []string</span><br></pre></td></tr></tbody></table></figure><p><strong>说明：</strong> 指定浏览器可以访问的响应头。例如，<code>Content-Length</code>。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExposeHeaders: []string{"Content-Length"},</span><br></pre></td></tr></tbody></table></figure><h3 id="5-6-AllowCredentials"><a href="#5-6-AllowCredentials" class="headerlink" title="5.6 AllowCredentials"></a>5.6 AllowCredentials</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllowCredentials bool</span><br></pre></td></tr></tbody></table></figure><p><strong>说明：</strong> 是否允许发送凭证（如Cookie）。设置为<code>true</code>时，<code>Access-Control-Allow-Origin</code>不能为<code>"*"</code>，必须指定具体的源。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllowCredentials: true,</span><br></pre></td></tr></tbody></table></figure><h3 id="5-7-MaxAge"><a href="#5-7-MaxAge" class="headerlink" title="5.7 MaxAge"></a>5.7 MaxAge</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxAge time.Duration</span><br></pre></td></tr></tbody></table></figure><p><strong>说明：</strong> 预检请求的缓存时间，单位为秒或时间.Duration。浏览器会缓存预检请求的结果，减少后续相同请求的预检次数。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxAge: 12 * time.Hour,</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> Gin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Gin </tag>
            
            <tag> CORS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Qt+MySql+Socket实现本地通讯</title>
      <link href="/2024/10/13/qt/ji-yu-qt-mysql-socket-shi-xian-ben-di-ju-yu-wang-tong-xun/"/>
      <url>/2024/10/13/qt/ji-yu-qt-mysql-socket-shi-xian-ben-di-ju-yu-wang-tong-xun/</url>
      
        <content type="html"><![CDATA[<h1 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h1><p>​这个项目的初衷是用来学习Socket网络通讯，并练习基础的MySql语句，但因时间有限，只实现了基本通讯功能，主要分为注册账号，增添好友，和本地通讯三个功能。</p><p>​因作者实力有限，所以代码中可能会遇到一些bug，如果读者遇到不懂的地方可以通过博客里面的联系方式找我讨论或者在评论区提问，还因为作者的英语水平有限，所以代码中有些变量的命名存在拼写错误，比如账号account,但我通篇都是acount，后期发现了也没有精力去修改了，类似其他的问题都可以在评论区提出。本代码完全由本人和chatgpt合力完成，未有抄袭，任何人都可以直接拿来参考共同学习。</p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>项目是用C++写的，需要有Qt基础和MySql基础，该项目的目的在于简单了解TCP/IP协议内容，简单实现Socket通讯，和一些数据库语句的基本用法，里面还有很多bug，最终比较遗憾的是只实现了本地多人通讯，做的时候没有往局域网通讯的方向去想，导致做完之后发现客户端的权限太大了，只能实现本地通讯。由于后续又有其他的任务，就没有精力去完善了，所以该项目就算是给大家举了一个反面教材，希望大家之后在做客户端的时候注意只用写请求就行，不要和数据库等内容相关联。觉得做的比较满意的部分是用服务器实现了多人通讯，也就是一个人可以通过指定好友向服务器发送请求，然后服务器会处理请求，并做出回应，将信息传递给接收者。</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="/../../images/image-20241016234807980.png" alt="image-20241016234807980"></p><p><img src="/../../images/image-20241016234823553.png" alt="image-20241016234823553"></p><p><img src="/../../images/image-20241016234733080.png" alt="image-20241016234733080"></p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p><img src="/../../images/image-20241207133303739.png" alt="image-20241207133303739"></p><h3 id="各个文件的作用"><a href="#各个文件的作用" class="headerlink" title="各个文件的作用"></a>各个文件的作用</h3><h4 id="Headers（头文件）"><a href="#Headers（头文件）" class="headerlink" title="Headers（头文件）"></a>Headers（头文件）</h4><ul><li><strong>addfrienddialog.h</strong>：<ul><li>这个头文件声明了 <code>AddFriendDialog</code> 类，通常用于管理“添加好友”的对话框。</li><li>可能包括用于输入好友账号、添加好友的按钮，以及处理输入和用户操作的接口声明。</li></ul></li><li><strong>chatpage.h</strong>：<ul><li>这个头文件声明了 <code>ChatPage</code> 类，通常用于表示一个聊天窗口，包含了聊天内容的展示、发送消息等功能。</li><li>包括聊天界面的基本操作，比如发送和接收消息的功能。</li></ul></li><li><strong>dialoglist.h</strong>：<ul><li>这个头文件声明了 <code>DialogList</code> 类，通常用于管理当前用户的好友列表和会话窗口。</li><li>包括显示好友列表的界面和管理与多个好友聊天的功能，允许用户选择好友并打开聊天窗口。</li></ul></li><li><strong>signup.h</strong>：<ul><li>这个头文件声明了 <code>Signup</code> 类，用于管理注册用户的界面。</li><li>包含用户注册的相关接口，比如输入用户名、密码以及确认注册的逻辑。</li></ul></li><li><strong>widget.h</strong>：<ul><li>这个头文件声明了主窗口（<code>Widget</code> 类），通常是应用程序启动后的主界面。</li><li>包括登录界面、注册按钮等初始操作的逻辑。</li></ul></li></ul><h4 id="Sources（源文件）"><a href="#Sources（源文件）" class="headerlink" title="Sources（源文件）"></a>Sources（源文件）</h4><ul><li><strong>addfrienddialog.cpp</strong>：<ul><li>这个源文件是 <code>addfrienddialog.h</code> 的实现部分，具体实现了添加好友对话框的功能。</li><li>例如：处理用户输入好友账号后的确认、取消等按钮的逻辑，以及与好友系统的交互。</li></ul></li><li><strong>chatpage.cpp</strong>：<ul><li>这个源文件实现了 <code>chatpage.h</code> 中的声明，提供了聊天窗口的具体功能。</li><li>包括发送消息、显示接收到的消息等实现，处理聊天界面的 UI 和消息逻辑。</li></ul></li><li><strong>dialoglist.cpp</strong>：<ul><li>这个源文件实现了 <code>dialoglist.h</code> 中的功能，主要用于管理好友列表和多对话窗口。</li><li>包括加载好友列表、打开聊天窗口、响应服务器的消息、添加好友的逻辑等。</li></ul></li><li><strong>main.cpp</strong>：<ul><li>这个文件是程序的入口，通常包含 <code>main()</code> 函数。</li><li>在这里会初始化应用程序，显示主窗口，并开始应用程序的事件循环。</li></ul></li><li><strong>signup.cpp</strong>：<ul><li>这个源文件是 <code>signup.h</code> 的实现部分，具体实现了注册窗口的功能。</li><li>包括检查用户输入是否有效、注册到数据库等具体的逻辑。</li></ul></li><li><strong>widget.cpp</strong>：<ul><li>这个文件是 <code>widget.h</code> 的实现部分，用于实现主窗口的功能。</li><li>包括初始化登录界面、用户输入处理以及登录、注册按钮的响应逻辑。</li></ul></li></ul><h4 id="Forms（UI-界面文件）"><a href="#Forms（UI-界面文件）" class="headerlink" title="Forms（UI 界面文件）"></a>Forms（UI 界面文件）</h4><ul><li><strong>addfrienddialog.ui</strong>：<ul><li>这个 <code>.ui</code> 文件定义了添加好友对话框的用户界面。</li><li>包含输入好友账号的文本框、确认和取消的按钮等界面元素。</li></ul></li><li><strong>chatpage.ui</strong>：<ul><li>这个 <code>.ui</code> 文件定义了聊天窗口的用户界面。</li><li>包含显示聊天记录的区域、输入消息的文本框、发送按钮等元素。</li></ul></li><li><strong>dialoglist.ui</strong>：<ul><li>这个 <code>.ui</code> 文件定义了好友列表的用户界面。</li><li>包含显示当前用户所有好友的列表、选择好友进行聊天的按钮等界面元素。</li></ul></li><li><strong>signup.ui</strong>：<ul><li>这个 <code>.ui</code> 文件定义了用户注册界面。</li><li>包含用户名、密码输入框，以及确认注册的按钮。</li></ul></li><li><strong>widget.ui</strong>：<ul><li>这个 <code>.ui</code> 文件定义了应用程序的主界面。</li><li>通常用于登录界面，包含账号、密码输入框、登录按钮、注册按钮等。</li></ul></li></ul><h3 id="项目的整体功能描述"><a href="#项目的整体功能描述" class="headerlink" title="项目的整体功能描述"></a>项目的整体功能描述</h3><ul><li><strong>Widget（主界面）</strong>：是程序的入口，包括登录和注册功能。</li><li><strong>Signup（注册界面）</strong>：用于新用户的注册功能。</li><li><strong>DialogList（好友列表界面）</strong>：在用户登录成功后，显示用户的好友列表，并允许用户与好友进行聊天。</li><li><strong>ChatPage（聊天界面）</strong>：用户可以与好友发送和接收消息。</li><li><strong>AddFriendDialog（添加好友对话框）</strong>：用于添加新好友的功能，输入好友的账号后请求添加。</li></ul><h3 id="项目工作流程"><a href="#项目工作流程" class="headerlink" title="项目工作流程"></a>项目工作流程</h3><p><strong>用户启动程序</strong>，首先看到的是登录界面（由 <code>widget</code> 类实现）。</p><ul><li>用户可以选择登录或注册。</li><li>如果用户选择注册，则会转到 <code>Signup</code> 界面。</li></ul><p><strong>登录成功后</strong>，进入到 <code>DialogList</code> 界面，可以看到当前好友列表。</p><ul><li>可以选择某个好友，点击后打开对应的聊天窗口（<code>ChatPage</code>）。</li><li>也可以通过“添加好友”按钮，打开 <code>AddFriendDialog</code> 对话框，添加新好友。</li></ul><p><strong>聊天窗口</strong>允许用户发送和接收消息，整个系统通过 <code>QTcpSocket</code> 与服务器通信来完成消息的收发。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p><img src="/../../images/image-20241013115547963.png" alt="image-20241013115547963"></p><h3 id="各个文件的作用-1"><a href="#各个文件的作用-1" class="headerlink" title="各个文件的作用"></a>各个文件的作用</h3><h4 id="Headers（头文件）-1"><a href="#Headers（头文件）-1" class="headerlink" title="Headers（头文件）"></a>Headers（头文件）</h4><ul><li><strong>chatserver.h：</strong><ul><li>这个头文件声明了 <code>ChatServer</code> 类，它是服务器的核心部分，用于管理客户端连接、消息处理等。</li><li>包含与客户端的连接管理、消息转发、登录验证等功能的声明。</li></ul></li><li><strong>widget.h：</strong><ul><li>这个头文件声明了 <code>Widget</code> 类，通常用于表示服务器的主窗口。</li><li>主要是服务器界面的基本操作，例如启动、停止服务器，查看连接状态等。</li></ul></li></ul><h4 id="Sources（源文件）-1"><a href="#Sources（源文件）-1" class="headerlink" title="Sources（源文件）"></a>Sources（源文件）</h4><ul><li><strong>chatserver.cpp</strong>：<ul><li>这个文件实现了 <code>chatserver.h</code> 中声明的 <code>ChatServer</code> 类。</li><li>包含了服务器启动、监听端口、接收客户端连接、处理客户端消息、消息转发等功能的具体实现。</li><li>例如，服务器可能通过 <code>QTcpServer</code> 和 <code>QTcpSocket</code> 来管理多个客户端连接。</li></ul></li><li><strong>main.cpp</strong>：<ul><li>这个文件是程序的入口，通常包含 <code>main()</code> 函数。</li><li><code>main()</code> 函数负责初始化应用程序、创建服务器主窗口，并启动服务器的事件循环。</li></ul></li><li><strong>widget.cpp</strong>：<ul><li>这个文件实现了 <code>widget.h</code> 中的 <code>Widget</code> 类。</li><li>主要实现服务器主窗口的功能，比如用户界面的交互（例如启动或停止服务器按钮）、显示当前连接状态、日志信息等。</li></ul></li></ul><h4 id="Forms（UI-界面文件）-1"><a href="#Forms（UI-界面文件）-1" class="headerlink" title="Forms（UI 界面文件）"></a>Forms（UI 界面文件）</h4><ul><li><strong>widget.ui：</strong><ul><li>这个 <code>.ui</code> 文件定义了服务器主界面的用户界面。</li><li>通常包括服务器控制的相关元素，例如启动和停止按钮、端口输入框，以及用于显示当前客户端连接状态的文本框或列表。</li></ul></li></ul><h3 id="项目的整体功能描述-1"><a href="#项目的整体功能描述-1" class="headerlink" title="项目的整体功能描述"></a>项目的整体功能描述</h3><ul><li><strong>服务器端程序</strong>：该项目是一个聊天应用的服务器端，负责处理客户端的连接、管理多个客户端之间的通信。</li><li><strong>主要功能：</strong><ul><li><strong>接受客户端的连接</strong>：通过监听指定端口，接受多个客户端的连接请求。</li><li><strong>处理登录和消息传递</strong>：在客户端登录时进行验证，并在客户端之间进行消息转发。</li><li><strong>提供主窗口界面</strong>：通过 GUI，提供服务器管理人员控制和查看服务器状态的接口。（本项目只有调试信息）</li></ul></li></ul><h3 id="文件具体职责描述"><a href="#文件具体职责描述" class="headerlink" title="文件具体职责描述"></a>文件具体职责描述</h3><ol><li><p><strong>chatserver.h 和 chatserver.cpp</strong>：</p><ul><li><p><strong><code>chatserver.h</code></strong> 中声明了服务器的所有必要接口，包括启动和停止服务器的方法，管理客户端连接的方法，和消息处理函数。</p></li><li><p><code>chatserver.cpp</code></p><p> 实现了这些功能，可能通过 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTcpServer</span><br></pre></td></tr></tbody></table></figure><p> 来监听端口，并通过 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTcpSocket</span><br></pre></td></tr></tbody></table></figure><p> 来管理每个连接的客户端。具体实现功能包括：</p><ul><li><strong>服务器启动</strong>：监听一个指定的端口，等待客户端连接。</li><li><strong>管理客户端连接</strong>：接受新连接，维护一个套接字列表，跟踪所有已连接的客户端。</li><li><strong>消息处理和转发</strong>：处理从某个客户端接收到的消息，并根据目标账号将消息转发给对应的客户端。</li></ul></li></ul></li><li><p><strong>widget.h 和 widget.cpp</strong>：</p><ul><li><strong><code>widget.h</code></strong> 和 <strong><code>widget.cpp</code></strong> 文件定义了服务器的主窗口，这个窗口用于服务器的 GUI 交互。</li><li>界面功能可能包括：<ul><li><strong>启动和停止服务器按钮</strong>：用于服务器管理人员控制服务器。</li><li><strong>显示连接信息</strong>：例如查看当前连接的客户端数量、日志输出等。</li><li><strong>信息输出</strong>：显示一些服务器的状态信息，例如某个客户端连接或断开连接的日志。</li></ul></li></ul></li><li><p><strong>widget.ui</strong>：</p><ul><li><strong><code>widget.ui</code></strong> 是服务器主窗口的 UI 文件，定义了界面布局，包括按钮、状态显示框等。</li><li>主要用于通过可视化方式管理服务器操作，比如监听端口的输入、查看连接信息、控制服务器启动/停止等。</li></ul></li></ol><h3 id="项目工作流程-1"><a href="#项目工作流程-1" class="headerlink" title="项目工作流程"></a>项目工作流程</h3><ol><li><strong>启动服务器</strong>：<ul><li>通过 <code>widget</code> 界面，服务器管理员可以选择启动服务器。</li><li>服务器会开始监听指定的端口，等待客户端连接。</li></ul></li><li><strong>客户端连接</strong>：<ul><li>当客户端尝试连接时，服务器通过 <code>chatserver</code> 类处理连接请求，并接受该连接。</li><li>服务器通过 <code>QTcpSocket</code> 来维护每个连接的客户端。</li></ul></li><li><strong>消息管理</strong>：<ul><li>客户端登录成功后，服务器接收来自客户端的消息，并根据消息目标账号查找对应的客户端进行转发。</li><li>服务器负责确保客户端之间的消息能够正确且高效地传递。</li></ul></li><li><strong>管理界面</strong>：<ul><li>通过 <code>widget</code> 界面，管理员可以查看所有已连接的客户端，查看每个客户端的 IP 地址和端口等信息。</li><li>管理员还可以通过 GUI 停止服务器或重启服务器。</li></ul></li></ol><h3 id="服务器的作用总结"><a href="#服务器的作用总结" class="headerlink" title="服务器的作用总结"></a>服务器的作用总结</h3><ul><li><strong>作为中央通信枢纽</strong>：QQ 项目客户端之间不能直接通信，因此需要一个服务器来接收和转发消息。</li><li><strong>管理用户登录和认证</strong>：服务器验证用户的登录信息，确保只有注册的用户可以访问服务。</li><li><strong>处理多个客户端连接</strong>：服务器可以同时处理多个客户端的连接，并根据需要将消息正确地路由到目标客户端。</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="/../../images/image-20241013121039178.png" alt="image-20241013121039178"></p><h3 id="friends表"><a href="#friends表" class="headerlink" title="friends表"></a>friends表</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-- auto-generated definition</span><br><span class="line">create table friends</span><br><span class="line">(</span><br><span class="line">    id         int auto_increment</span><br><span class="line">        primary key,</span><br><span class="line">    user_id    int                                     not null,</span><br><span class="line">    friend_id  int                                     not null,</span><br><span class="line">    status     enum ('pending', 'accepted', 'blocked') not null,</span><br><span class="line">    created_at datetime default CURRENT_TIMESTAMP      null,</span><br><span class="line">    updated_at datetime default CURRENT_TIMESTAMP      null on update CURRENT_TIMESTAMP,</span><br><span class="line">    constraint user_id</span><br><span class="line">        unique (user_id, friend_id),</span><br><span class="line">    constraint friends_ibfk_1</span><br><span class="line">        foreign key (user_id) references users (id)</span><br><span class="line">            on delete cascade,</span><br><span class="line">    constraint friends_ibfk_2</span><br><span class="line">        foreign key (friend_id) references users (id)</span><br><span class="line">            on delete cascade</span><br><span class="line">)</span><br><span class="line">    engine = InnoDB;</span><br><span class="line"></span><br><span class="line">create index friend_id</span><br><span class="line">    on friends (friend_id);</span><br></pre></td></tr></tbody></table></figure><h3 id="messages表（未用到）"><a href="#messages表（未用到）" class="headerlink" title="messages表（未用到）"></a>messages表（未用到）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- auto-generated definition</span><br><span class="line">create table messages</span><br><span class="line">(</span><br><span class="line">    id          int auto_increment</span><br><span class="line">        primary key,</span><br><span class="line">    sender_id   int                                not null,</span><br><span class="line">    receiver_id int                                not null,</span><br><span class="line">    content     text                               not null,</span><br><span class="line">    timestamp   datetime default CURRENT_TIMESTAMP null,</span><br><span class="line">    constraint messages_ibfk_1</span><br><span class="line">        foreign key (sender_id) references users (id),</span><br><span class="line">    constraint messages_ibfk_2</span><br><span class="line">        foreign key (receiver_id) references users (id)</span><br><span class="line">)</span><br><span class="line">    engine = InnoDB;</span><br><span class="line"></span><br><span class="line">create index receiver_id</span><br><span class="line">    on messages (receiver_id);</span><br><span class="line"></span><br><span class="line">create index sender_id</span><br><span class="line">    on messages (sender_id);</span><br></pre></td></tr></tbody></table></figure><h3 id="users表"><a href="#users表" class="headerlink" title="users表"></a>users表</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- auto-generated definition</span><br><span class="line">create table users</span><br><span class="line">(</span><br><span class="line">    id       int auto_increment</span><br><span class="line">        primary key,</span><br><span class="line">    username varchar(255) not null,</span><br><span class="line">    password varchar(255) not null,</span><br><span class="line">    acount   varchar(255) null,</span><br><span class="line">    constraint username</span><br><span class="line">        unique (username)</span><br><span class="line">)</span><br><span class="line">    engine = InnoDB;</span><br></pre></td></tr></tbody></table></figure><p>数据库没什么好说的，先听基础数据库教程，很容易就能理解。</p><h2 id="实现教程"><a href="#实现教程" class="headerlink" title="实现教程"></a>实现教程</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>先在Qt安装MySql驱动，网上有很多教程。</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"widget.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">// 连接数据库</span></span><br><span class="line">    QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">"QMYSQL"</span>);</span><br><span class="line"></span><br><span class="line">    db.<span class="built_in">setHostName</span>(<span class="string">"localhost"</span>);<span class="comment">//改为自己的，默认localhost</span></span><br><span class="line">    db.<span class="built_in">setPort</span>(<span class="number">3306</span>);<span class="comment">//修改为自己的端口号，默认3306</span></span><br><span class="line">    db.<span class="built_in">setDatabaseName</span>(<span class="string">"qtconnectmysql"</span>);<span class="comment">//提前创建该项目数据库，并增添上述板块的三个表</span></span><br><span class="line">    db.<span class="built_in">setUserName</span>(<span class="string">"root"</span>);<span class="comment">//设为自己一开始设置的，默认root</span></span><br><span class="line">    db.<span class="built_in">setPassword</span>(<span class="string">"123456"</span>);<span class="comment">//设置注册数据库的密码，默认123456</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!db.<span class="built_in">open</span>()) {</span><br><span class="line">        <span class="built_in">qDebug</span>(<span class="string">"Sql connect failed."</span>);</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; db.<span class="built_in">lastError</span>().<span class="built_in">text</span>();</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="literal">nullptr</span>, <span class="string">"警告"</span>, <span class="string">"无法连接数据库"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">qDebug</span>(<span class="string">"Sql connected."</span>);</span><br><span class="line">    }</span><br><span class="line">    Widget w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>注意修改数据库配置</strong></p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>先允许服务端，客户端可以复制成多份，分别同时运行，登入的账号即可实现通讯功能。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>百度网盘：</p><p>链接:<a href="https://pan.baidu.com/s/1n5ODY9eVyCv6VlUD5ycS0Q?pwd=yxme">https://pan.baidu.com/s/1n5ODY9eVyCv6VlUD5ycS0Q?pwd=yxme</a> 提取码:yxme </p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
          <category> MySql </category>
          
          <category> TcpSocket </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> MySql </tag>
            
            <tag> TcpSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yolov5部署全流程</title>
      <link href="/2024/07/23/yolov5-bu-shu-liu-cheng/"/>
      <url>/2024/07/23/yolov5-bu-shu-liu-cheng/</url>
      
        <content type="html"><![CDATA[<p>本教程是基于yolov在window11部署的入门教程，部分内容和源码摘自<a href="https://blog.csdn.net/weixin_73785971/article/details/139389534?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E4%BD%BF%E7%94%A8yolov5%E5%AE%9E%E7%8E%B0%E5%88%86%E8%BE%A8%E7%9F%AD%E8%A2%96%E5%92%8C%E9%95%BF%E8%A2%96&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-139389534.142">（实战）用yolov5实现图像识别_yolov5识别-CSDN博客</a></p><p>如有错误，请在评论区指出</p><h2 id="1-下载yolov5项目"><a href="#1-下载yolov5项目" class="headerlink" title="1.下载yolov5项目"></a>1.下载yolov5项目</h2><p>在GitHub上下载yolov5，链接在下面<br><a href="https://github.com/ultralytics/yolov5">https://github.com/ultralytics/yolov5</a><br>下载完成后解压到合适位置即可</p><h2 id="2-安装Anoconda-Pycharm"><a href="#2-安装Anoconda-Pycharm" class="headerlink" title="2.安装Anoconda Pycharm"></a>2.安装Anoconda Pycharm</h2><p>Anocanda安装教程<br><a href="https://blog.csdn.net/fan18317517352/article/details/123035625">https://blog.csdn.net/fan18317517352/article/details/123035625</a><br>PyCharm安装教程<br><a href="https://blog.csdn.net/qq_44809707/article/details/122501118">https://blog.csdn.net/qq_44809707/article/details/122501118</a><br>按照教程安装即可，注意<strong>正确配置环境变量</strong></p><h2 id="3-安装CUDA，Cudnn，Pytorch-关键"><a href="#3-安装CUDA，Cudnn，Pytorch-关键" class="headerlink" title="3.安装CUDA，Cudnn，Pytorch(关键)"></a>3.安装CUDA，Cudnn，Pytorch(关键)</h2><p>如果默认安装项目自带的requirements.txt中的包的话，最后会<strong>以cpu跑项目，这将会导致训练模型的速度非常慢</strong>，原因是requirements.txt中的pytorch为cpu版本，解决办法如下：</p><p>先按照教程安装合适的cuda，Cudnn：</p><p><a href="https://blog.csdn.net/m0_45447650/article/details/123704930?ops_request_misc=%7B%22request_id%22:%22172173622416800175759760%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=172173622416800175759760&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123704930-null-null.142%5Ev100%5Epc_search_result_base1&amp;utm_term=cuda%E5%AE%89%E8%A3%85&amp;spm=1018.2226.3001.4187">CUDA安装教程（超详细）-CSDN博客</a></p><p>接着安装cuda版本对应的pytorch，教程如下（<strong>切记切记！！！！！ 安装Gpu版本的</strong>）：</p><p><a href="https://blog.csdn.net/weixin_44752340/article/details/130542629?ops_request_misc=%7B%22request_id%22:%22172169655016800188568943%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=172169655016800188568943&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-130542629-null-null.142%5Ev100%5Epc_search_result_base1&amp;utm_term=pytorch&amp;spm=1018.2226.3001.4187">2023最新pytorch安装（超详细版）-CSDN博客</a></p><h2 id="4-用Anoconda创建虚拟环境"><a href="#4-用Anoconda创建虚拟环境" class="headerlink" title="4.用Anoconda创建虚拟环境"></a>4.用Anoconda创建虚拟环境</h2><p>先按win+r ，输入cmd</p><p>创建虚拟环境conda create -n yolov5</p><p>激活虚拟环境   conda activate yolov5</p><p><strong>注释掉 requirements.txt中的</strong></p><p>15行 torch&gt;=1.8.0  # see <a href="https://pytorch.org/get-started/locally">https://pytorch.org/get-started/locally</a> (recommended)<br>16行 torchvision&gt;=0.9.0</p><p>在行首加#即可</p><p>安装依赖库conda install -r requirements.txt</p><p>如果下载特别慢的话注意是否是因为没有<strong>更换国内镜像</strong></p><h2 id="5-用Pycharm打开项目并更改环境"><a href="#5-用Pycharm打开项目并更改环境" class="headerlink" title="5.用Pycharm打开项目并更改环境"></a>5.用Pycharm打开项目并更改环境</h2><p>打开pycharm</p><p>打开项目所在文件夹</p><p>更改环境为刚创建的yolov5环境</p><p>这一步教程如下：</p><p>第一次用先激活conda环境<a href="https://blog.csdn.net/Father_Of_Soft/article/details/132582043">激活Conda环境并在pycharm使用_pycharm激活conda环境-CSDN博客</a></p><p>再选择 <a href="https://blog.csdn.net/Aer_7z/article/details/131801694?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Ctr-2-131801694-blog-123141645.235%5Ev43%5Epc_blog_bottom_relevance_base7&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Ctr-2-131801694-blog-123141645.235%5Ev43%5Epc_blog_bottom_relevance_base7&amp;utm_relevant_index=5">pycharm如何配置Anaconda虚拟环境_pycharm配置anaconda运行环境-CSDN博客</a></p><p>配置完成后可以先运行项目目录中的detect.py文件，再看yolov5-master\runs\detect中的运行结果</p><p>如果有结果则怎么环境配置成功</p><h2 id="6-制作数据集"><a href="#6-制作数据集" class="headerlink" title="6.制作数据集"></a>6.制作数据集</h2><p>先找数据集</p><p><a href="https://blog.csdn.net/luochao5862426/article/details/79564311?ops_request_misc=%7B%22request_id%22:%22172173859316800225532438%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=172173859316800225532438&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-79564311-null-null.142%5Ev100%5Epc_search_result_base1&amp;utm_term=%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BD%91%E7%AB%99&amp;spm=1018.2226.3001.4187">史上最全数据集网站汇总-CSDN博客</a></p><p>下载标注工具labelimg，同时了解一些常见用法</p><p><a href="https://blog.csdn.net/qq_45688164/article/details/136070818?ops_request_misc=%7B%22request_id%22:%22172173866216800180650469%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=172173866216800180650469&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-136070818-null-null.142%5Ev100%5Epc_search_result_base1&amp;utm_term=pycharm%E4%B8%8B%E8%BD%BDlabelimg&amp;spm=1018.2226.3001.4187">labelimg 在pycharm下载使用_pycharm安装labelimg-CSDN博客</a></p><p>在yolov5的根目录下建一个文件夹 dataset，然后在dataset里建三个文件夹 images，imagesets， annotations，然后在imagesets里新建一个文件夹main。images文件夹是存放未识别的jpg文件（也就是我们用来训练模型的原始图片）</p><p>大概格式</p><p>yolov5(项目文件夹)</p><p>​——dataset</p><p>​——images(训练模型的原始照片)</p><p>​——imagesets</p><p>​——main</p><p>​——annotations（标注过的xml文件）</p><p>将需要标注的jpg图片放到上述images文件夹中，打开labelImg，用PascalVOC模式，Change Save Dir改为 annotations文件夹（上述创建的）</p><p>使用：</p><p>按w呼出矩形框用来标记，按d是下一张，按a是上一张，因为前面已经打开了自动保存，那么annotations里会自动保存了xml文件。</p><h2 id="7-增加三个文件"><a href="#7-增加三个文件" class="headerlink" title="7.增加三个文件"></a>7.增加三个文件</h2><h4 id="第一个"><a href="#第一个" class="headerlink" title="第一个"></a>第一个</h4><p>在dataset文件夹中创建py代码split_train_val.py：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line"><span class="comment">#xml文件的地址，根据自己的数据进行修改 xml一般存放在annotations下</span></span><br><span class="line">parser.add_argument(<span class="string">'--xml_path'</span>, default=<span class="string">'annotations'</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">'input xml label path'</span>)</span><br><span class="line"><span class="comment">#数据集的划分，地址选择自己数据下的ImageSets/Main</span></span><br><span class="line">parser.add_argument(<span class="string">'--txt_path'</span>, default=<span class="string">'imagesets/main'</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">'output txt label path'</span>)</span><br><span class="line">opt = parser.parse_args()</span><br><span class="line"></span><br><span class="line">trainval_percent = <span class="number">1.0</span></span><br><span class="line">train_percent = <span class="number">0.9</span></span><br><span class="line">xmlfilepath = opt.xml_path</span><br><span class="line">txtsavepath = opt.txt_path</span><br><span class="line">total_xml = os.listdir(xmlfilepath)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(txtsavepath):</span><br><span class="line">    os.makedirs(txtsavepath)</span><br><span class="line"></span><br><span class="line">num = <span class="built_in">len</span>(total_xml)</span><br><span class="line">list_index = <span class="built_in">range</span>(num)</span><br><span class="line">tv = <span class="built_in">int</span>(num * trainval_percent)</span><br><span class="line">tr = <span class="built_in">int</span>(tv * train_percent)</span><br><span class="line">trainval = random.sample(list_index, tv)</span><br><span class="line">train = random.sample(trainval, tr)</span><br><span class="line"></span><br><span class="line">file_trainval = <span class="built_in">open</span>(txtsavepath + <span class="string">'/trainval.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">file_test = <span class="built_in">open</span>(txtsavepath + <span class="string">'/test.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">file_train = <span class="built_in">open</span>(txtsavepath + <span class="string">'/train.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">file_val = <span class="built_in">open</span>(txtsavepath + <span class="string">'/val.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list_index:</span><br><span class="line">    name = total_xml[i][:-<span class="number">4</span>] + <span class="string">'\n'</span></span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> trainval:</span><br><span class="line">        file_trainval.write(name)</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> train:</span><br><span class="line">            file_train.write(name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            file_val.write(name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        file_test.write(name)</span><br><span class="line"></span><br><span class="line">file_trainval.close()</span><br><span class="line">file_train.close()</span><br><span class="line">file_val.close()</span><br><span class="line">file_test.close()**运行**了上面这串代码之后，会在imagesets\main里生成四个文件</span><br><span class="line"></span><br><span class="line">分别为test.txt    train.txt     trainval.txtval.txt</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="第二个"><a href="#第二个" class="headerlink" title="第二个"></a>第二个</h4><p>在dataset文件夹中新建py代码文件voc_label.py：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getcwd</span><br><span class="line"></span><br><span class="line">sets = [<span class="string">'train'</span>, <span class="string">'val'</span>, <span class="string">'test'</span>]</span><br><span class="line">classes = [<span class="string">"bus"</span>]   <span class="comment"># 改成自己的类别，我只用于识别bus所以只有一个标签</span></span><br><span class="line">abs_path = os.getcwd()</span><br><span class="line"><span class="built_in">print</span>(abs_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">size, box</span>):</span><br><span class="line">    dw = <span class="number">1.</span> / (size[<span class="number">0</span>])</span><br><span class="line">    dh = <span class="number">1.</span> / (size[<span class="number">1</span>])</span><br><span class="line">    x = (box[<span class="number">0</span>] + box[<span class="number">1</span>]) / <span class="number">2.0</span> - <span class="number">1</span></span><br><span class="line">    y = (box[<span class="number">2</span>] + box[<span class="number">3</span>]) / <span class="number">2.0</span> - <span class="number">1</span></span><br><span class="line">    w = box[<span class="number">1</span>] - box[<span class="number">0</span>]</span><br><span class="line">    h = box[<span class="number">3</span>] - box[<span class="number">2</span>]</span><br><span class="line">    x = x * dw</span><br><span class="line">    w = w * dw</span><br><span class="line">    y = y * dh</span><br><span class="line">    h = h * dh</span><br><span class="line">    <span class="keyword">return</span> x, y, w, h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_annotation</span>(<span class="params">image_id</span>):</span><br><span class="line">    <span class="comment">#修改自己电脑上对应文件目录，infile是打开xml文件的</span></span><br><span class="line">    in_file = <span class="built_in">open</span>(<span class="string">'D:/develop-python/yolov5-6.0/dataset/annotations/%s.xml'</span> % (image_id), encoding=<span class="string">'UTF-8'</span>)</span><br><span class="line">    out_file = <span class="built_in">open</span>(<span class="string">'D:/develop-python/yolov5-6.0/dataset/labels/%s.txt'</span> % (image_id), <span class="string">'w'</span>)</span><br><span class="line">    tree = ET.parse(in_file)</span><br><span class="line">    root = tree.getroot()</span><br><span class="line">    size = root.find(<span class="string">'size'</span>)</span><br><span class="line">    w = <span class="built_in">int</span>(size.find(<span class="string">'width'</span>).text)</span><br><span class="line">    h = <span class="built_in">int</span>(size.find(<span class="string">'height'</span>).text)</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> root.<span class="built_in">iter</span>(<span class="string">'object'</span>):</span><br><span class="line">        difficult = obj.find(<span class="string">'difficult'</span>)</span><br><span class="line">        <span class="keyword">if</span> difficult <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            difficult = <span class="built_in">int</span>(difficult.text)  <span class="comment"># 假设difficult是整数类型</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            difficult = <span class="number">0</span>  <span class="comment"># 或者你可以设置一个默认值，或者不处理difficult标签</span></span><br><span class="line">        cls = obj.find(<span class="string">'name'</span>).text</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> classes <span class="keyword">or</span> <span class="built_in">int</span>(difficult) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        cls_id = classes.index(cls)</span><br><span class="line">        xmlbox = obj.find(<span class="string">'bndbox'</span>)</span><br><span class="line">        b = (<span class="built_in">float</span>(xmlbox.find(<span class="string">'xmin'</span>).text), <span class="built_in">float</span>(xmlbox.find(<span class="string">'xmax'</span>).text), <span class="built_in">float</span>(xmlbox.find(<span class="string">'ymin'</span>).text),</span><br><span class="line">             <span class="built_in">float</span>(xmlbox.find(<span class="string">'ymax'</span>).text))</span><br><span class="line">        b1, b2, b3, b4 = b</span><br><span class="line">        <span class="comment"># 标注越界修正</span></span><br><span class="line">        <span class="keyword">if</span> b2 &gt; w:</span><br><span class="line">            b2 = w</span><br><span class="line">        <span class="keyword">if</span> b4 &gt; h:</span><br><span class="line">            b4 = h</span><br><span class="line">        b = (b1, b2, b3, b4)</span><br><span class="line">        bb = convert((w, h), b)</span><br><span class="line">        out_file.write(<span class="built_in">str</span>(cls_id) + <span class="string">" "</span> + <span class="string">" "</span>.join([<span class="built_in">str</span>(a) <span class="keyword">for</span> a <span class="keyword">in</span> bb]) + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">wd = getcwd()</span><br><span class="line"><span class="keyword">for</span> image_set <span class="keyword">in</span> sets:</span><br><span class="line">    <span class="comment">#修改为自己电脑上对应目录</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'D:/develop-python/yolov5-6.0/dataset/labels/'</span>):</span><br><span class="line">        os.makedirs(<span class="string">'D:/develop-python/yolov5-6.0/dataset/labels/'</span>)</span><br><span class="line">    image_ids = <span class="built_in">open</span>(<span class="string">'D:/develop-python/yolov5-6.0/dataset/imagesets/main/%s.txt'</span> % (image_set)).read().strip().split()</span><br><span class="line">    list_file = <span class="built_in">open</span>(<span class="string">'D:/develop-python/yolov5-6.0/dataset/%s.txt'</span> % (image_set), <span class="string">'w'</span>)</span><br><span class="line">    <span class="keyword">for</span> image_id <span class="keyword">in</span> image_ids:</span><br><span class="line">        list_file.write(abs_path + <span class="string">'\images\%s.jpg\n'</span> % (image_id))</span><br><span class="line">        convert_annotation(image_id)</span><br><span class="line">    list_file.close()</span><br></pre></td></tr></tbody></table></figure><p><strong>注意修改代码中的目录</strong></p><p><strong>运行</strong>后dataset文件夹中会生成labels文件夹，以及三个txt文件：test.txt，train.txt，val.txt：</p><h4 id="第三个"><a href="#第三个" class="headerlink" title="第三个"></a>第三个</h4><p>然后在data文件夹中新建CustomData.yaml：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">train: D:\dev\yolov5-master\dataset\train.txt <span class="comment">#注意更改地址</span></span><br><span class="line">val: D:\dev\yolov5-master\dataset\val.txt <span class="comment">#注意更改地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># number of classes，有多少个标签就填多少个</span></span><br><span class="line"></span><br><span class="line">nc: <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># class names        我只有一个bus标签所以写bus</span></span><br><span class="line"></span><br><span class="line">names: </span><br><span class="line">  <span class="number">0</span>: 长袖</span><br><span class="line">  <span class="number">1</span>: 短袖</span><br><span class="line">  <span class="number">2</span>: OK</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="8-介绍并修改train-py"><a href="#8-介绍并修改train-py" class="headerlink" title="8.介绍并修改train.py"></a>8.介绍并修改train.py</h2><p><strong>train.py</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">def parse_opt(known=False):</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument('--weights', type=str, default=ROOT / 'yolov5s.pt', help='initial weights path')</span><br><span class="line">    parser.add_argument('--cfg', type=str, default='models/yolov5s.yaml', help='model.yaml path')</span><br><span class="line">    parser.add_argument('--data', type=str, default=ROOT / 'data/CustomData.yaml', help='dataset.yaml path')</span><br><span class="line">    parser.add_argument('--hyp', type=str, default=ROOT / 'data/hyps/hyp.scratch.yaml', help='hyperparameters path')</span><br><span class="line">    parser.add_argument('--epochs', type=int, default=300)</span><br><span class="line">    parser.add_argument('--batch-size', type=int, default=16, help='total batch size for all GPUs')</span><br><span class="line">    parser.add_argument('--imgsz', '--img', '--img-size', type=int, default=640, help='train, val image size (pixels)')</span><br><span class="line">    parser.add_argument('--rect', action='store_true', help='rectangular training')</span><br><span class="line">    parser.add_argument('--resume', nargs='?', const=True, default=False, help='resume most recent training')</span><br><span class="line">    parser.add_argument('--nosave', action='store_true', help='only save final checkpoint')</span><br><span class="line">    parser.add_argument('--noval', action='store_true', help='only validate final epoch')</span><br><span class="line">    parser.add_argument('--noautoanchor', action='store_true', help='disable autoanchor check')</span><br><span class="line">    parser.add_argument('--evolve', type=int, nargs='?', const=300, help='evolve hyperparameters for x generations')</span><br><span class="line">    parser.add_argument('--bucket', type=str, default='', help='gsutil bucket')</span><br><span class="line">    parser.add_argument('--cache', type=str, nargs='?', const='ram', help='--cache images in "ram" (default) or "disk"')</span><br><span class="line">    parser.add_argument('--image-weights', action='store_true', help='use weighted image selection for training')</span><br><span class="line">    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')</span><br><span class="line">    parser.add_argument('--multi-scale', action='store_true', help='vary img-size +/- 50%%')</span><br><span class="line">    parser.add_argument('--single-cls', action='store_true', help='train multi-class data as single-class')</span><br><span class="line">    parser.add_argument('--adam', action='store_true', help='use torch.optim.Adam() optimizer')</span><br><span class="line">    parser.add_argument('--sync-bn', action='store_true', help='use SyncBatchNorm, only available in DDP mode')</span><br><span class="line">    parser.add_argument('--workers', type=int, default=8, help='maximum number of dataloader workers')</span><br><span class="line">    parser.add_argument('--project', default=ROOT / 'runs/train', help='save to project/name')</span><br><span class="line">    parser.add_argument('--name', default='exp', help='save to project/name')</span><br><span class="line">    parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')</span><br><span class="line">    parser.add_argument('--quad', action='store_true', help='quad dataloader')</span><br><span class="line">    parser.add_argument('--linear-lr', action='store_true', help='linear LR')</span><br><span class="line">    parser.add_argument('--label-smoothing', type=float, default=0.0, help='Label smoothing epsilon')</span><br><span class="line">    parser.add_argument('--patience', type=int, default=100, help='EarlyStopping patience (epochs without improvement)')</span><br><span class="line">    parser.add_argument('--freeze', type=int, default=0, help='Number of layers to freeze. backbone=10, all=24')</span><br><span class="line">    parser.add_argument('--save-period', type=int, default=-1, help='Save checkpoint every x epochs (disabled if &lt; 1)')</span><br><span class="line">    parser.add_argument('--local_rank', type=int, default=-1, help='DDP parameter, do not modify')</span><br></pre></td></tr></tbody></table></figure><p>epochs：指的就是训练过程中整个数据集将被迭代多少次，默认是300次，次数越多模型越精准花的时间也越多</p><p>batch-size：一次看完多少张图片才进行权重更新，梯度下降的mini-batch。</p><p>cfg：存储模型结构的配置文件</p><p>data：存储训练、测试数据的文件</p><p>img-size：输入图片宽高。</p><p>rect：进行矩形训练</p><p>resume：恢复最近保存的模型开始训练</p><p>nosave：仅保存最终checkpoint</p><p>notest：仅测试最后的epoch</p><p>evolve：进化超参数</p><p>bucket：gsutil bucket</p><p>cache-images：缓存图像以加快训练速度</p><p>weights：权重文件路径</p><p>name： 重命名results.txt to results_name.txt</p><p>device：cuda device, i.e. 0 or 0,1,2,3 or cpu</p><p>adam：使用adam优化</p><p>multi-scale：多尺度训练，img-size +/- 50%</p><p>single-cls：单类别的训练集</p><p><strong>我们需要修改的是weight 、cfg 、data。weight用的是我们前面下载的yolov5s.pt的权重文件，cfg用的就是yolov5s.yaml，data则用的是我们前编写的CustomData.yaml</strong></p><h2 id="9-介绍detect-py"><a href="#9-介绍detect-py" class="headerlink" title="9.介绍detect.py"></a>9.介绍detect.py</h2><p><strong>detect.py</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">def parse_opt():</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument('--weights', nargs='+', type=str, default=ROOT /'yolov5s.pt' , help='model path(s)')</span><br><span class="line">    parser.add_argument('--source', type=str, default=ROOT / 'data/images', help='file/dir/URL/glob, 0 for webcam')</span><br><span class="line">    parser.add_argument('--imgsz', '--img', '--img-size', nargs='+', type=int, default=[640], help='inference size h,w')</span><br><span class="line">    parser.add_argument('--conf-thres', type=float, default=0.25, help='confidence threshold')</span><br><span class="line">    parser.add_argument('--iou-thres', type=float, default=0.45, help='NMS IoU threshold')</span><br><span class="line">    parser.add_argument('--max-det', type=int, default=1000, help='maximum detections per image')</span><br><span class="line">    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')</span><br><span class="line">    parser.add_argument('--view-img', action='store_true', help='show results')</span><br><span class="line">    parser.add_argument('--save-txt', action='store_true', help='save results to *.txt')</span><br><span class="line">    parser.add_argument('--save-conf', action='store_true', help='save confidences in --save-txt labels')</span><br><span class="line">    parser.add_argument('--save-crop', action='store_true', help='save cropped prediction boxes')</span><br><span class="line">    parser.add_argument('--nosave', action='store_true', help='do not save images/videos')</span><br><span class="line">    parser.add_argument('--classes', nargs='+', type=int, help='filter by class: --classes 0, or --classes 0 2 3')</span><br><span class="line">    parser.add_argument('--agnostic-nms', action='store_true', help='class-agnostic NMS')</span><br><span class="line">    parser.add_argument('--augment', action='store_true', help='augmented inference')</span><br><span class="line">    parser.add_argument('--visualize', action='store_true', help='visualize features')</span><br><span class="line">    parser.add_argument('--update', action='store_true', help='update all models')</span><br><span class="line">    parser.add_argument('--project', default=ROOT / 'runs/detect', help='save results to project/name')</span><br><span class="line">    parser.add_argument('--name', default='exp', help='save results to project/name')</span><br><span class="line">    parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')</span><br><span class="line">    parser.add_argument('--line-thickness', default=3, type=int, help='bounding box thickness (pixels)')</span><br><span class="line">    parser.add_argument('--hide-labels', default=False, action='store_true', help='hide labels')</span><br><span class="line">    parser.add_argument('--hide-conf', default=False, action='store_true', help='hide confidences')</span><br><span class="line">    parser.add_argument('--half', action='store_true', help='use FP16 half-precision inference')</span><br><span class="line">    parser.add_argument('--dnn', action='store_true', help='use OpenCV DNN for ONNX inference')</span><br><span class="line">    opt = parser.parse_args()</span><br><span class="line">    opt.imgsz *= 2 if len(opt.imgsz) == 1 else 1  # expand</span><br><span class="line">    print_args(FILE.stem, opt)</span><br><span class="line">    return opt</span><br></pre></td></tr></tbody></table></figure><p>weights：训练的权重</p><p>source：测试数据，可以是图片/视频路径，也可以是’0’(电脑自带摄像头),也可以是rtsp等视频流</p><p>output：网络预测之后的图片/视频的保存路径</p><p>img-size：网络输入图片大小</p><p>conf-thres：置信度阈值</p><p>iou-thres：做nms的iou阈值</p><p>device：设置设备</p><p>view-img：是否展示预测之后的图片/视频，默认False</p><p>save-txt：是否将预测的框坐标以txt文件形式保存，默认False</p><p>classes：设置只保留某一部分类别，形如0或者0 2 3</p><p>agnostic-nms：进行nms是否也去除不同类别之间的框，默认False</p><p>augment：推理的时候进行多尺度，翻转等操作(TTA)推理</p><p>update：如果为True，则对所有模型进行strip_optimizer操作，去除pt文件中的优化器等信息，默认为False</p><p><strong>目前还不用修改这里的参数，后面训练完模型才修改权重文件。</strong></p><h2 id="10-训练模型"><a href="#10-训练模型" class="headerlink" title="10.训练模型"></a>10.训练模型</h2><p>运行train.py开始训练模型</p><p>当风扇开始嗡嗡转的时候就说明开始训练了</p><p>注意的是，训练的时候比较吃内存，别手贱打开那么多页面什么的</p><p>跑完之后，会在runs/train/exp/weights/下生成.pt文件，这个<strong>best.pt</strong>文件就是我们训练出来的权重文件</p><p>好了，然后再回去detect.py文件里，把<strong>权重文件换成我们自己训练的权重文件</strong></p><p>也就是weights这一行改成自己训练的权重文件的路径即可，把自己要检测的文件放到data/images里，然后运行detect.py即可开始识别所得结果会放在runs/detect文件夹内</p><p>大功告成！！！！！</p>]]></content>
      
      
      <categories>
          
          <category> 经历 </category>
          
          <category> 计算机视觉 </category>
          
          <category> 环境配置 </category>
          
          <category> yolov </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> yolov </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15届蓝桥杯</title>
      <link href="/2024/06/01/15-lan-qiao-bei/"/>
      <url>/2024/06/01/15-lan-qiao-bei/</url>
      
        <content type="html"><![CDATA[<h2 id="蓝桥杯"><a href="#蓝桥杯" class="headerlink" title="蓝桥杯"></a>蓝桥杯</h2><p><strong>从刚开始报考的时候，觉着自己能拿个省一就心满意足了，当时认为拿个省一非常困难，毕竟在蓝桥杯a组，同台选手都比较厉害，但是到最后考试的时候，发现其实题目并不是特别的难，当然还有自己不会写的题，让我感到意外的是省赛的题对算法考察的并不是特别多，也就是如果对一些常见的题型比较熟悉，并且积累足够的代码量，基本就可以拿个省一，毕竟这个获奖比例确实挺高的😄😄。</strong><br><strong>考完省赛后，爽完了半个月，在五一期间还和同学一起去洛阳玩了4天，天天吃好吃的😄。</strong><br><strong>五月中旬花了一个星期的时间备考国赛，不过国赛题真难啊，尤其是第13届a组那一套题，看了半天就会写出来一道签到题，其他的都不会写，非常打击自信心。到了最后一个星期，我本打算再复习冲刺一波，于是我复习一遍之前做过的几套题，没想到写完一遍之后还是有很多题不会写。就这样破罐子破摔吧，我直接和室友狂打一个星期的永劫无间征神之路，我用的是岳山，战马刀伤害贼高，嘎嘎乱杀。最后国赛的时候，感觉写的还不错，会写的都写上了，部分题也能混几分，唯一遗憾的是到最后十分钟的时候发现有一道简单的15分的题被我忽略了，我一开始是写完第一道大题，看了半天第二道大题，就直接从后面开始写了，没想到最后隔了一道挺简单的一道题，好像是关于求满足一个公式的最大长度什么的，没时间码出来了😭。最后拿了个国优秀奖，还是挺满意的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 经历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经历 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
